<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Coverate Results</title>
<style>
	.error { background: #F8D5D8 }
	.count { font-weight: bold; border-radius: 3px }
	.pass .count { background: #BFFFBF;}	.error .count { background: #F8D5D8; color: red}</style>
</head>
<body>
<h1>lib/micropilot.js (97%)</h1>

<pre>/*! vim:set ts=2 sw=2 sts=2 expandtab */
/*! This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */

<span class="pass" data-count="1"><span class="count">1</span>"use strict";
</span>
/**
  * Example Usage for module:
  *
  * Usage:
  * ```
  *  Micropilot('mystudy').start().record({'a':1}).then(function(mtp){
  *    mtp.upload(UPLOAD_URL + mtp.studyid);
  *  })
  * ```
  *
  * record `{a:1, ts: Date.now()}`.  Then upload.
  * ```
  * require('micropilot').Micropilot('simplestudyid').start().
  *    record({a:1,ts: Date.now()}).then(function(m) m.ezupload())
  *    // which actually uploads!
  * ```
  *
  * For 1 day, record any data notified on `Observer` topics `['topic1', 'topic2']`
  * then upload to `<url>`, after that 24 hour `Fuse` completes.
  * ```
  * require("micropilot").Micropilot('otherstudyid').start().watch(['topic1','topic2']).
  *   lifetime(24 * 60 * 60 * 1000).then(
  *     function(mtp){ mtp.upload(url); mtp.stop() })
  * ```
  *
  * How a more realistic study might look.
  * ```
  * let monitor_tabopen = require('micropilot').Micropilot('tapopenstudy');
  * var tabs = require('tabs');
  * tabs.on('ready', function () {
  *   monitor_tabopen.record({'msg:' 'tab ready', 'ts': Date.now()})
  * });
  *
  * monitor_tabopen.lifetime(86400*1000).then(function(mon){mon.ezupload()});
  *   // Fuse:  24 hours-ish after first start, upload
  *
  * if (user_tells_us_to_stop_snooping){
  *   monitor_tabopen.stop();
  * }
  * ```
  *
  * @module main
  *
  */

/**! Metadata about this module. */
<span class="pass" data-count="1"><span class="count">1</span>exports.metadata = {
  "stability": "experimental",
  "engines": {
    "Firefox": "17",
    "Fennec": "17"
  }
};
</span>
/*! this gets them into the xpi tarball, if they are present
  Don't use the comment/regex trick because comments don't go
  through to covered code :/
*/
<span class="pass" data-count="1"><span class="count">1</span>try {
  <span class="pass" data-count="1"><span class="count">1</span>require("indexed-db");
</span>  <span class="pass" data-count="1"><span class="count">1</span>require("./indexed-db-17");
</span>} catch (e){}
</span>
/*!*/
<span class="pass" data-count="1"><span class="count">1</span>const { Cu } = require("chrome");
</span><span class="pass" data-count="1"><span class="count">1</span>const xulApp = require('sdk/system/xul-app');
</span>
<span class="pass" data-count="1"><span class="count">1</span>const { Class } = require('sdk/core/heritage');
</span><span class="pass" data-count="1"><span class="count">1</span>const { Collection } = require("collection");
</span><span class="pass" data-count="1"><span class="count">1</span>const { defer, promised, resolve } = require('api-utils/promise');
</span><span class="pass" data-count="1"><span class="count">1</span>if (xulApp.versionInRange(xulApp.version,17,18)) { // 17 only
  <span class="error" data-count="0"><span class="count">0</span>var { indexedDB } = requireAny(['./indexed-db-17'],
      "no indexed-db found.  If fx version < 18, include indexed-db-17.js in build.");
</span>} else {
  <span class="pass" data-count="1"><span class="count">1</span>var { indexedDB } = require('indexed-db');
</span>}
</span><span class="pass" data-count="1"><span class="count">1</span>const observer = require("observer-service");
</span><span class="pass" data-count="1"><span class="count">1</span>const myprefs = require("simple-prefs").prefs;
</span><span class="pass" data-count="1"><span class="count">1</span>const Request = require("request").Request;
</span><span class="pass" data-count="1"><span class="count">1</span>const {storage} = require("simple-storage");
</span><span class="pass" data-count="1"><span class="count">1</span>const timers = require("timers");
</span><span class="pass" data-count="1"><span class="count">1</span>const uuid = require('sdk/util/uuid').uuid;
</span>

/** Random UUID as string, without braces.
 *
 * @return {string} random uuid without braces
 *
 * @memberOf main
 * @name uu
 */
<span class="pass" data-count="1"><span class="count">1</span>let uu = exports.uu = function(){
        <span class="pass" data-count="26"><span class="count">26</span>return uuid().number.slice(1,-1)
}</span>;
</span>

/** Object with "passing" HTTP status codes.
 *
 * @memberOf main
 * @name GOODSTATUS
 */
<span class="pass" data-count="1"><span class="count">1</span>const GOODSTATUS = exports.GOODSTATUS = {
  //"O": 0,
  "200": 200,
  "201": 201,
  "202": 202,
  "203": 203,
  "204": 204
};
</span>
/** Upload url
  *
  * @memberOf main
  * @name UPLOAD_URL
  */
<span class="pass" data-count="1"><span class="count">1</span>let UPLOAD_URL = exports.UPLOAD_URL = "https://testpilot.mozillalabs.com/submit/testpilot_micropilot_";
</span>
/**!*/
// Warning: micropilot steals the simple store 'micropilot' key by name
<span class="pass" data-count="1"><span class="count">1</span>if (storage.micropilot===undefined) storage.micropilot = {};
</span>
/** common generic function to handle request errors
  *
  * Console errors the error code.
  *
  * @memberOf main
  * @name requestError
  */
<span class="pass" data-count="1"><span class="count">1</span>let requestError = function(evt) console.error("ERROR",evt.target.errorCode);
</span><span class="pass" data-count="1"><span class="count">1</span>let requestBlocked = function(evt) console.log("BLOCKED",evt);
</span>

/** log IFF `prefs.micropilot` is set.
  *
  * @return undefined
  * @name microlog
  */
<span class="pass" data-count="1"><span class="count">1</span>let microlog = exports.microlog = function(){
    <span class="pass" data-count="38"><span class="count">38</span>myprefs.micropilotlog  && console.log.apply(null, arguments);
</span>}



/**
  * EventStore Constructor (Heritage)
  * @module EventStore
  */
<span class="pass" data-count="1"><span class="count">1</span>l</span>et EventStore = exports.EventStore = Class({

  /** Create an event store.
    *
    * @param {string} collection used in db and objectStore names.
    * @param {string} key autoincrement key, (default: "eventstoreid")
    *
    * @return EventStore instance
    * @memberOf EventStore
    * @name initialize
    */
  initialize: function(collection,keyname){
    <span class="pass" data-count="23"><span class="count">23</span>this.collection = collection;
</span>    <span class="pass" data-count="23"><span class="count">23</span>this.keyname = keyname || "eventstoreid";
</span>  },
  type: "EventStore",
  /** promise a indexedDB connection to `"micropilot-"+this.collection`.
    *
    * If first connection to db, creates object store:
    *
    * `createObjectStore(that.collection,{keyPath: that.keyname, autoIncrement: true }`
    *
    * Resolves on success with (`request.result`)
    *
    * @memberOf EventStore
    * @name db
    * @return promise
    */
  db: function(){
    <span class="pass" data-count="1018"><span class="count">1018</span>let that = this;
</span>    <span class="pass" data-count="1018"><span class="count">1018</span>let {promise, resolve} = defer();
</span>    // TODO each EventStore has different Db, so the createObjectStore will work.  Is this gross?
    <span class="pass" data-count="1018"><span class="count">1018</span>let req = indexedDB.open("micropilot-"+that.collection,1);
</span>    <span class="pass" data-count="1018"><span class="count">1018</span>req.onerror = requestError;
</span>    <span class="pass" data-count="1018"><span class="count">1018</span>req.onupgradeneeded = function (event) {
      <span class="pass" data-count="9"><span class="count">9</span>let objectStore = req.result.createObjectStore(that.collection,
        {keyPath: that.keyname, autoIncrement: true });
</span>      <span class="pass" data-count="9"><span class="count">9</span>microlog("micropilot-object-store-made:", that.collection )
    }</span>;
</span>    // called after onupgradeneeded
    <span class="pass" data-count="1018"><span class="count">1018</span>req.onsuccess = function(event) {
      <span class="pass" data-count="1018"><span class="count">1018</span>resolve(req.result);
</span>    };
</span>    <span class="pass" data-count="1018"><span class="count">1018</span>req.onblocked = requestBlocked;
</span>
    <span class="pass" data-count="1018"><span class="count">1018</span>return promise
  }</span>,
  /** promises to add data to the autoincrementing objectStore.
    *
    * Resolves on success with (`{id: newkey, data:data}`)
    *
    * @param {object} data jsonable data
    *
    * @memberOf EventStore
    * @name add
    * @return promise
    */
  add: function(data){
    <span class="pass" data-count="1007"><span class="count">1007</span>let that = this;
</span>    <span class="pass" data-count="1007"><span class="count">1007</span>let {promise, resolve} = defer();
</span>    <span class="pass" data-count="1007"><span class="count">1007</span>this.db().then(function(db){
      <span class="pass" data-count="1007"><span class="count">1007</span>let req = db.transaction([that.collection], "readwrite").
        objectStore(that.collection).add(data);
</span>      <span class="pass" data-count="1007"><span class="count">1007</span>req.onsuccess = function (evt) {
        <span class="pass" data-count="1007"><span class="count">1007</span>let newkey = evt.target.result;
</span>        <span class="pass" data-count="1007"><span class="count">1007</span>resolve({id: newkey, data:data});
</span>      };
</span>      <span class="pass" data-count="1007"><span class="count">1007</span>req.onerror = requestError;
</span>      <span class="pass" data-count="1007"><span class="count">1007</span>req.onblocked = requestBlocked;
</span>
    })
    <span class="pass" data-count="1007"><span class="count">1007</span>r</span>eturn promise
  }</span>,
  /** promise all data from the collection (async).
    *
    * Resolves on success (`data`).
    *
    * *Note*: non-blocking, only guarantees complete list of data if all
    * writes have finished.
    *
    * @memberOf EventStor
    * @name getAll
    * @return promise
    */
  getAll: function(){
    // using getAll() doesn't seem to work, and isn't cross-platform
    <span class="pass" data-count="11"><span class="count">11</span>let {promise, resolve} = defer();
</span>    <span class="pass" data-count="11"><span class="count">11</span>let that = this;
</span>    <span class="pass" data-count="11"><span class="count">11</span>this.db().then(function(db){
      <span class="pass" data-count="11"><span class="count">11</span>let data = [];
</span>      <span class="pass" data-count="11"><span class="count">11</span>let req = db.transaction([that.collection], "readonly").objectStore(that.collection).openCursor()
      <span class="pass" data-count="11"><span class="count">11</span>r</span>eq.onsuccess = function(event) {
        <span class="pass" data-count="1018"><span class="count">1018</span>let cursor = event.target.result;
</span>        <span class="pass" data-count="1018"><span class="count">1018</span>if (cursor) {
          <span class="pass" data-count="1007"><span class="count">1007</span>data.push(cursor.value);
</span>          <span class="pass" data-count="1007"><span class="count">1007</span>cursor.continue();
</span>        }
        else {
          <span class="pass" data-count="11"><span class="count">11</span>resolve(data);
</span>        }
</span>      };
</span>      <span class="pass" data-count="11"><span class="count">11</span>req.onerror = requestError;
</span>      <span class="pass" data-count="11"><span class="count">11</span>req.onblocked = requestBlocked;
</span>
    })
    <span class="pass" data-count="11"><span class="count">11</span>r</span>eturn promise;
</span>  },
  /** promise to drop the database.
    *
    * Resolves onsuccess (`request.result`)
    * @memberOf EventStore
    * @name clear
    * @return promise
    */
  clear: function(){
    <span class="pass" data-count="4"><span class="count">4</span>let that = this;
</span>    <span class="pass" data-count="4"><span class="count">4</span>let {promise, resolve} = defer();
</span>    <span class="pass" data-count="4"><span class="count">4</span>let req = indexedDB.deleteDatabase("micropilot-"+that.collection,1);
</span>    <span class="pass" data-count="4"><span class="count">4</span>req.onsuccess = function(event) {
      <span class="pass" data-count="4"><span class="count">4</span>resolve(req.result);
</span>    }
    <span class="pass" data-count="4"><span class="count">4</span>r</span>eq.onerror = requestError;
</span>    <span class="pass" data-count="4"><span class="count">4</span>req.onblocked = requestBlocked;
</span>    <span class="pass" data-count="4"><span class="count">4</span>return promise;
</span>  }
});
</span>
/**
  * Micropilot Heritage Object
  *
  * Persists over multiple runs.
  * (Persistence achieved using `simple-store`, which ties a Micropilot into
  * a particular addon)
  *
  * @param {string} studyid unique key to id the study (used by dbs, prefs)
  * @module Micropilot
  *
  * @returns Micropilot instance
  */
<span class="pass" data-count="1"><span class="count">1</span>let Micropilot = exports.Micropilot = Class({
  /** Initialize the Micropilot
    *
    * internals:
    *
    * * `_watched`: observed topics
    * * `eventstore`: an EventStore
    * * `_config`: simple-store configuration
    *   * `personid`:  a `uu()`  (set this if you want.)
    *   * `_startdate`:  now, or then (if revived)
    * * `willrecord`:  a brake on event recording
    *
    * @memberOf Micropilot
    * @name initialize
    * @param {String} studyid Id for persistent store, db.
    */
  initialize: function(studyid){
      // setup the indexdb
      <span class="pass" data-count="20"><span class="count">20</span>this.studyid = studyid;
</span>      <span class="pass" data-count="20"><span class="count">20</span>this._watched = {};
</span>      <span class="pass" data-count="20"><span class="count">20</span>this.eventstore = EventStore(this.studyid);
</span>      <span class="pass" data-count="20"><span class="count">20</span>if (storage.micropilot[studyid] === undefined) {
        <span class="pass" data-count="20"><span class="count">20</span>storage.micropilot[studyid] = {
          personid: uu(),
          startdate:  Date.now()  // start now
        }
      }</span>
</span>      <span class="pass" data-count="20"><span class="count">20</span>this._config = storage.micropilot[studyid]; </span>// persists
      <span class="pass" data-count="20"><span class="count">20</span>this._startdate = this._config.startdate;
</span>      <span class="pass" data-count="20"><span class="count">20</span>this.willrecord = false; </span>// won't record.
  },
  type: 'Micropilot',


  /** get and set the startDate
    *
    * @memberOf Micropilot
    * @name startdate
    */
  get startdate() this._startdate,
  // resetting the startdate kills existing lifetime / fuse
  set startdate(ts) {
    <span class="pass" data-count="3"><span class="count">3</span>this.stop();
</span>    <span class="pass" data-count="3"><span class="count">3</span>this._startdate = this._config.startdate = ts;
</span>  },
  /** promise of all recorded event data
    *
    * Resolve (`data`)
    * @memberOf Micropilot
    * @name data
    * @return promise
    */
  data: function() this.eventstore.getAll(),

  /** promise to clear all data (by dropping the db)
    *
    * Resolve(`request.response`) // of the dropDatabse
    * @memberOf Micropilot
    * @name clear
    * @return promise
    */
  clear: function() this.eventstore.clear(),

  /** promise of `EventStore.add`, which is {id:<>,data:<>}
    * unless record "doesn't happen" because of non-running
    *
    * @memberOf Micropilot
    * @name record
    * @return promise
    */
  record: function(data){
    // remember, `resolve` turns values into promises, and is noop on promises
    <span class="pass" data-count="9"><span class="count">9</span>if (! this.willrecord) return resolve(undefined);
</span>
    // todo, what if it's not jsonable?
    <span class="pass" data-count="4"><span class="count">4</span>JSON.stringify(data);
</span>    <span class="pass" data-count="4"><span class="count">4</span>microlog("micropilot-record:", JSON.stringify(data));
</span>    <span class="pass" data-count="4"><span class="count">4</span>return this.eventstore.add(data)
  }</span>,

  /** promise the study (setting a Fuse)
    *
    *
    * Fuse set as {start: this.startdate,duration:duration}
    * (modify startdate to 'run from some other time')
    *
    * False or Undefined duration subls forever / never resolves
    *
    * Note:  calls `stop()` and `start()` as side-effects
    *
    * Resolves when the study fuse resolves.
    *
    * example:
    *
    *   `Micropilot('mystudy').lifetime(1000).then(function(mtp){mtp.stop()})`
    *
    * @param {integer} duration milliseconds to run Fuse
    * @memberOf Micropilot
    * @name lifetime
    * @return promise
    *
    */
  lifetime:  function(duration){
    <span class="pass" data-count="6"><span class="count">6</span>this.stop();
</span>    <span class="pass" data-count="6"><span class="count">6</span>this.willrecord = true; </span>// restart!
    <span class="pass" data-count="6"><span class="count">6</span>let deferred = defer();
</span>    <span class="pass" data-count="6"><span class="count">6</span>let that = this;
</span>    <span class="pass" data-count="6"><span class="count">6</span>this.start();
</span>    // iff!
    <span class="pass" data-count="6"><span class="count">6</span>if (duration){
      // should this allow / mix all fuse options?
      <span class="pass" data-count="4"><span class="count">4</span>this.fuse = Fuse({start: this.startdate,duration:duration, resolve_this: that});
</span>      <span class="pass" data-count="4"><span class="count">4</span>return this.fuse;
</span>    } else {
      // no duration, so infinite, so nothing to resolve.
      <span class="pass" data-count="2"><span class="count">2</span>return deferred.promise;
</span>    }
</span>  },

  /** allow record (`this.willrecord` -> `true`)
    *
    * @return {micropilot} this
    * @memberOf Micropilot
    * @name start
    */
  start:  function(){
    <span class="pass" data-count="11"><span class="count">11</span>this.willrecord = true;
</span>    <span class="pass" data-count="11"><span class="count">11</span>return this;
</span>  },
  /** stop the study (unset the fuse, `this.willrecord` -> `false`)
    *
    * (after stopping, `record` will not work, unless one `start()` or
    * or `willrecord` -> `true`)
    *
    * @return {micropilot} this
    * @memberOf Micropilot
    * @name stop
    */
  stop:  function(){
    <span class="pass" data-count="14"><span class="count">14</span>this.willrecord = false;
</span>    <span class="pass" data-count="14"><span class="count">14</span>this.fuse !== undefined && this.fuse.stop();
</span>    <span class="pass" data-count="14"><span class="count">14</span>delete this.fuse;
</span>    <span class="pass" data-count="14"><span class="count">14</span>return this;
</span>  },

  /** (internal) watch a topic, add to `observer-service`
   *
   * @param {string} topic topic to watch.
   * @memberOf Micropilot
   * @name _watch
   * @return undefined
   */
  _watch: function(topic){
    <span class="pass" data-count="8"><span class="count">8</span>if (this._watched[topic]) return
</span>
    <span class="pass" data-count="8"><span class="count">8</span>let that = this;
</span>    <span class="pass" data-count="8"><span class="count">8</span>let cb;
</span>    <span class="pass" data-count="8"><span class="count">8</span>if (this._watchfn !== undefined){
      <span class="pass" data-count="5"><span class="count">5</span>cb = function(subject,data) that._watchfn.call(that,topic,subject,data);
</span>    } else {
      <span class="pass" data-count="3"><span class="count">3</span>cb = function(subject,data) {<span class="pass" data-count="1"><span class="count">1</span>that.record({"msg":topic,ts:Date.now(),"subject":subject,"data":data})}</span>;
</span>    }
</span>    <span class="pass" data-count="8"><span class="count">8</span>let o = observer.add(topic,cb); </span>// add to global watch list
    <span class="pass" data-count="8"><span class="count">8</span>this._watched[topic] = cb;
</span>  },

  /** add topics to watch (non-destructive)
    *
    * @param {array} watch_list list of topics
    * @return {micropilot} this
    * @memberOf Micropilot
    * @name watch
    */
  watch: function(watch_list){
      <span class="pass" data-count="6"><span class="count">6</span>let that = this;
</span>      <span class="pass" data-count="6"><span class="count">6</span>watch_list.forEach(function(t) that._watch(t))
      <span class="pass" data-count="6"><span class="count">6</span>r</span>eturn this;
</span>  },

  /** (internal) stop watching topic
    * @memberOf Micropilot
    * @name _unwatch
    * @return undefined
    */
  _unwatch: function(topic){
    <span class="pass" data-count="8"><span class="count">8</span>let cb = this._watched[topic];
</span>    <span class="pass" data-count="8"><span class="count">8</span>cb && observer.remove(topic,cb);
</span>    <span class="pass" data-count="8"><span class="count">8</span>delete this._watched[topic];
</span>  },

  /** unwatch some topics (destructive)
    * if `unwatch_list` is undefined, unwatch all.
    *
    * @param {array} unwatch_list list of topics to remove.  If undefined, unwatch all.
    * @memberOf Micropilot
    * @name unwatch
    * @return {micropilot} this
    */
  unwatch: function(unwatch_list){
    <span class="pass" data-count="5"><span class="count">5</span>if (unwatch_list === undefined) unwatch_list = Object.keys(this._watched);
</span>    <span class="pass" data-count="5"><span class="count">5</span>let that = this;
</span>    <span class="pass" data-count="5"><span class="count">5</span>unwatch_list.forEach(function(t) that._unwatch(t));
</span>    <span class="pass" data-count="5"><span class="count">5</span>return this;
</span>  },
  /** promise simplified upload with strong opinions and retry semantics
    *
    * Options:
    *
    * - `url`:  defaults to `UPLOAD_URL + mtp.studyname`
    * - `maxtries`:  Number of tries.  (`3`)
    * - `interval`:  How long to wait between tries (60 min - `60*60*1000`)
    * - `killaddon`:  Should the addon delete itself on completion? (`false`)
    *
    * *Note 1*:  https://github.com/gregglind/micropilot/issues/2
    *
    * *Note 2*:  `_config.completed` will will go to `true` on success or not.
    *
    * *Note 3*:  Adds some keys to `_config` persistence:
    *
    * - `completed`
    * - `uploadcounter`
    *
    * This is Subject To Change, and just a starting point for how to talk
    * about study state.
    *
    * @param {Object} options Upload options.
    * @memberOf Micropilot
    * @name ezupload
    * @return promise
    */
  ezupload: function(options){
    <span class="pass" data-count="1"><span class="count">1</span>let { promise, resolve } = defer();
</span>    <span class="pass" data-count="1"><span class="count">1</span>let {url,maxtries,interval,killaddon:killpref} = options;
</span>    <span class="pass" data-count="1"><span class="count">1</span>let that = this;
</span>    <span class="pass" data-count="1"><span class="count">1</span>url = url || (UPLOAD_URL + that.studyid);
</span>    <span class="pass" data-count="1"><span class="count">1</span>microlog("micropilot-ezupload:",url );
</span>
    <span class="pass" data-count="1"><span class="count">1</span>maxtries = maxtries || 3
    <span class="pass" data-count="1"><span class="count">1</span>i</span>nterval = interval || 60 * 60 * 1000; </span>// 60 minutes

    <span class="pass" data-count="1"><span class="count">1</span>let mycleanup = function(){
        <span class="pass" data-count="1"><span class="count">1</span>that._config.completed = true ; </span>// whatever properties you want
        <span class="pass" data-count="1"><span class="count">1</span>let p = that.stop();
</span>        <span class="pass" data-count="1"><span class="count">1</span>p = that.clear();
</span>        <span class="pass" data-count="1"><span class="count">1</span>if (killpref) {
          <span class="error" data-count="0"><span class="count">0</span>microlog("micropilot: killpref on!")
          <span class="error" data-count="0"><span class="count">0</span>r</span>esolve(p.then(killaddon)); </span>  // stop the study, clear the data, uninstall the addon.
        } else {
          <span class="pass" data-count="1"><span class="count">1</span>resolve(p)
        }</span>
</span>    }

    <span class="pass" data-count="1"><span class="count">1</span>i</span>f (this._config.uploadcounter === undefined) this._config.uploadcounter = 0;
</span>    <span class="pass" data-count="1"><span class="count">1</span>let myupload = function() {
      <span class="pass" data-count="4"><span class="count">4</span>if (that._config.uploadcounter >= maxtries) { <span class="pass" data-count="1"><span class="count">1</span>mycleanup(that); </span><span class="pass" data-count="1"><span class="count">1</span>return}</span><span class="pass" data-count="3"><span class="count">3</span>;</span> </span> // give up!
      <span class="pass" data-count="3"><span class="count">3</span>that._config.uploadcounter += 1;
</span>
      <span class="pass" data-count="3"><span class="count">3</span>that.upload(url).then(function(response){
        <span class="pass" data-count="3"><span class="count">3</span>let dump_response = function(response){
          <span class="pass" data-count="3"><span class="count">3</span>return JSON.stringify({status: response.status, text: response.text})
        }</span>
        <span class="pass" data-count="3"><span class="count">3</span>i</span>f (! GOODSTATUS[response.status]) {  // try again in interval ms
          <span class="pass" data-count="3"><span class="count">3</span>microlog("micropilot-ezupload-fail:", dump_response(response),"retrying in:", interval);
</span>          <span class="pass" data-count="3"><span class="count">3</span>require('timers').setTimeout(function(){<span class="pass" data-count="3"><span class="count">3</span>myupload()}</span>, interval)
        }</span> else {
          <span class="error" data-count="0"><span class="count">0</span>microlog("micropilot-ezupload-success:",dump_response(response))
          <span class="error" data-count="0"><span class="count">0</span>m</span>ycleanup();
</span>        }
</span>      })
    }</span>
    <span class="pass" data-count="1"><span class="count">1</span>m</span>yupload();
</span>    <span class="pass" data-count="1"><span class="count">1</span>return promise;
</span>  },

  /** promise to upload the data
    *
    * Options:
    * - `simulate`:  don't post, promise the request
    * - `uploadid`:  an id for the upload
    *
    * Resolves
    * - if POST, after oncomplete (response)
    * - if `options.simulate` (request)
    *
    * @param {string} url url to POST.
    * @param {object} options some options, below.
    * @memberOf Micropilot
    * @name upload
    * @return promise
    */
  upload:  function(url,options){
    // get all... is this tangled between getting and posting?
    // attempt to post
    <span class="pass" data-count="6"><span class="count">6</span>options = options===undefined ? {} : options;
</span>    <span class="pass" data-count="6"><span class="count">6</span>let that = this;
</span>    <span class="pass" data-count="6"><span class="count">6</span>let simulate = options.simulate;
</span>    <span class="pass" data-count="6"><span class="count">6</span>let { promise, resolve } = defer();
</span>    <span class="pass" data-count="6"><span class="count">6</span>let uploadid = options.uploadid || uu(); </span>// specific to the upload
    <span class="pass" data-count="6"><span class="count">6</span>this.data().then(function(data){
      <span class="pass" data-count="6"><span class="count">6</span>microlog("micropilot-willupload-data:", JSON.stringify(data));
</span>      <span class="pass" data-count="6"><span class="count">6</span>let payload = {events:data};
</span>      <span class="pass" data-count="6"><span class="count">6</span>payload.ts = Date.now();
</span>      <span class="pass" data-count="6"><span class="count">6</span>payload.uploadid = uploadid;
</span>      <span class="pass" data-count="6"><span class="count">6</span>payload.personid = that._config.personid;
</span>      <span class="pass" data-count="6"><span class="count">6</span>snoop().then(function(userdata){
        <span class="pass" data-count="6"><span class="count">6</span>payload.userdata = userdata;
</span>        <span class="pass" data-count="6"><span class="count">6</span>microlog("micropilot-willupload-content:", JSON.stringify(payload));
</span>        <span class="pass" data-count="6"><span class="count">6</span>let R = Request({
          url: url,
          headers: {
          },
          content: JSON.stringify(payload),
          contentType: "application/json",

          onComplete: function (response) {
            <span class="pass" data-count="4"><span class="count">4</span>microlog("micropilot-upload-response:",response.status);
</span>            <span class="pass" data-count="4"><span class="count">4</span>microlog("micropilot-upload-response:",response.text);
</span>            <span class="pass" data-count="4"><span class="count">4</span>resolve(response) }</span>,
        });
</span>        <span class="pass" data-count="6"><span class="count">6</span>if (simulate) {
          <span class="pass" data-count="2"><span class="count">2</span>resolve(R);
</span>        } else {
          <span class="pass" data-count="4"><span class="count">4</span>R.post();
</span>        }
</span>      })
    }</span>);
</span>    <span class="pass" data-count="6"><span class="count">6</span>return promise;
</span>  }

});
</span>
/** gather general user data, including addons, os, etc.
  *
  * Properties:  appname, location, fxVersion, os, updateChannel, addons list
  * @return promise promise of userdata
  * @name snoop
  * @memberOf main
  */
<span class="pass" data-count="1"><span class="count">1</span>let snoop = exports.snoop = function(){
  <span class="pass" data-count="7"><span class="count">7</span>let { promise, resolve } = defer();
</span>  <span class="pass" data-count="7"><span class="count">7</span>let LOCALE_PREF = "general.useragent.locale";
</span>  <span class="pass" data-count="7"><span class="count">7</span>let UPDATE_CHANNEL_PREF = "app.update.channel";
</span>  <span class="pass" data-count="7"><span class="count">7</span>let xa = require("xul-app");
</span>  <span class="pass" data-count="7"><span class="count">7</span>let prefs = require('preferences-service');
</span>
  <span class="pass" data-count="7"><span class="count">7</span>let u = {};
</span>  <span class="pass" data-count="7"><span class="count">7</span>u.appname = xa.name;
</span>  <span class="pass" data-count="7"><span class="count">7</span>u.location = prefs.get(LOCALE_PREF)
  <span class="pass" data-count="7"><span class="count">7</span>u</span>.fxVersion = xa.version;
</span>  <span class="pass" data-count="7"><span class="count">7</span>u.os = require('runtime').os;
</span>  <span class="pass" data-count="7"><span class="count">7</span>u.updateChannel = prefs.get(UPDATE_CHANNEL_PREF)

  <span class="pass" data-count="7"><span class="count">7</span>l</span>et { AddonManager } = Cu.import("resource://gre/modules/AddonManager.jsm");
</span>  <span class="pass" data-count="7"><span class="count">7</span>u.addons = [];
</span>  <span class="pass" data-count="7"><span class="count">7</span>AddonManager.getAllAddons(function(addonList){
    <span class="pass" data-count="7"><span class="count">7</span>Array.forEach(addonList,function(a){
      <span class="pass" data-count="63"><span class="count">63</span>let o = {};
</span>      <span class="pass" data-count="63"><span class="count">63</span>['id','name','appDisabled','isActive','type','userDisabled'].forEach(function(k){
        <span class="pass" data-count="378"><span class="count">378</span>o[k] = a[k]
      }</span>)
      <span class="pass" data-count="63"><span class="count">63</span>u</span>.addons.push(o);
</span>    })
    <span class="pass" data-count="7"><span class="count">7</span>r</span>esolve(u);
</span>  })
  <span class="pass" data-count="7"><span class="count">7</span>r</span>eturn promise;
</span>}

/** Fuse Heritage Class
  *
  * @module Fuse
  */
<span class="pass" data-count="1"><span class="count">1</span>l</span>et Fuse = exports.Fuse = Class({
  /**
    * Fuses trigger (resolve their promise) no sooner than `duration + start`
    *
    * (like a dynamite fuse)
    *
    * Options:
    *
    * - `start`:  start time for the fuse
    * - `duration`: how long to run.
    * - `pulseinterval`:  if defined, use a `setInterval` timer (see below)
    * - `resolve_this`:  the `this` passed into the `then` during resolution (default undefined)
    * - `pulsefn`:  if `setInterval` timer, run this function during every `pulse`
    *
    * `setInterval` vs. `setTimeout`:  Fuse is normally a `setTimeout`.  If you
    * want finer control over it (including being able to modify the timers of
    * running Fuses), use `pulseInterval` to make a `setInterval` timer.
    *
    * Note 1: "Short Fuses":  When the `duration` is very short, we don't guaranteed
    * millisecond accuracy!
    *
    * Note 2:  Restart.  If a Fuse 'should fire' while Firefox is not running,
    * it will fire the next time it can.
    *
    * Note 3:  Blast from the Past.  Fuses fire IFF
    *
    *   ```
    *   Date.now() >= (that.start + that.duration)
    *   ```
    *
    * Note 4: Persist a fuse over restarts.
    *
    * ```
    *   let {storage} = require("simple-storage");
    *   if (! storage.firststart) ss.firststart = Date.now(); // tied to addon
    *   Fuse({start: storeage.firststart,duration:86400 * 7 * 1000 }).then(
    *    function(){ Micropilot('delayedstudy').start()} )
    * ```
    *
    * @memberOf Fuse
    * @param {Object} options
    * @returns Fuse instance
    * @name initialize
    */
  initialize: function(options){
    <span class="pass" data-count="9"><span class="count">9</span>let {start,duration,pulseinterval,resolve_this,pulsefn} = options;
</span>    <span class="pass" data-count="9"><span class="count">9</span>this.pulseinterval =  pulseinterval;
</span>    <span class="pass" data-count="9"><span class="count">9</span>let that = this;
</span>    <span class="pass" data-count="9"><span class="count">9</span>this.start = start;
</span>    <span class="pass" data-count="9"><span class="count">9</span>this.duration = duration;
</span>    <span class="pass" data-count="9"><span class="count">9</span>let { promise, resolve } = defer();
</span>    <span class="pass" data-count="9"><span class="count">9</span>this.promise = promise;
</span>    <span class="pass" data-count="9"><span class="count">9</span>this.resolve = resolve;
</span>    // should this be setInterval, or setTimeout?
    // setInterval allows one to modify the fuse while running
    // more easily, but setTimeout is much more precise.
    <span class="pass" data-count="9"><span class="count">9</span>if (pulseinterval){
      <span class="pass" data-count="2"><span class="count">2</span>this.timerid = timers.setInterval(function(){
        <span class="pass" data-count="12"><span class="count">12</span>if (that.checking) {
          <span class="error" data-count="0"><span class="count">0</span>return; </span> // prevent races
        }
</span>        <span class="pass" data-count="12"><span class="count">12</span>that.checking = true;
</span>        <span class="pass" data-count="12"><span class="count">12</span>if (pulsefn) {<span class="pass" data-count="11"><span class="count">11</span>pulsefn(that)}</span>
</span>        <span class="pass" data-count="12"><span class="count">12</span>if (! duration) return;
</span>        <span class="pass" data-count="12"><span class="count">12</span>if (Date.now() >= (that.start + that.duration)){
          <span class="pass" data-count="1"><span class="count">1</span>that.resolve(resolve_this);
</span>          <span class="pass" data-count="1"><span class="count">1</span>that.stop();
</span>        }
</span>        <span class="pass" data-count="12"><span class="count">12</span>that.checking=false;
</span>      },pulseinterval);
</span>    } else {
      // TODO, what is setTimeout on a negative?
      <span class="pass" data-count="7"><span class="count">7</span>that.checking=false;
</span>      <span class="pass" data-count="7"><span class="count">7</span>let timerunningsofar = (Date.now() - this.start);
</span>      <span class="pass" data-count="7"><span class="count">7</span>if (duration <= timerunningsofar) { // really short intervals
        <span class="pass" data-count="1"><span class="count">1</span>that.resolve(resolve_this);
</span>        <span class="pass" data-count="1"><span class="count">1</span>this.stop();
</span>      } else {
        <span class="pass" data-count="6"><span class="count">6</span>this.timerid = timers.setTimeout(function(){
          <span class="pass" data-count="4"><span class="count">4</span>that.resolve(resolve_this);
</span>          <span class="pass" data-count="4"><span class="count">4</span>that.stop();
</span>        }, duration - timerunningsofar);
</span>      }
</span>    }
</span>  },
  /** promise the promise.  Resolves with `resolve_this`
    *
    * @memberOf Fuse
    * @name then
    * @return promise
    */
  get then() this.promise.then,

  type: 'Fuse',
  /** stop the fuse (clear the timeout).
    *
    * @return {fuse} this
    * @memberOf Fuse
    * @name stop
    */
  stop: function(){
    <span class="pass" data-count="9"><span class="count">9</span>if (this.timerid) {
      <span class="pass" data-count="8"><span class="count">8</span>timers.clearTimeout(this.timerid);
</span>    }
</span>    <span class="pass" data-count="9"><span class="count">9</span>return this;
</span>  }
});
</span>

/** Self-destruct (uninstall) this addon
  *
  * @param {string} id addon id
  * @return promise (sdk/adddon/installer).uninstall
  * @memberOf main
  * @name killaddon
  */
<span class="pass" data-count="1"><span class="count">1</span>let killaddon = exports.killaddon = function(id){
  <span class="pass" data-count="1"><span class="count">1</span>id = id === undefined ? require('self').id : id;
</span>  <span class="pass" data-count="1"><span class="count">1</span>microlog("attempting to remove addon:", id);
</span>  <span class="pass" data-count="1"><span class="count">1</span>return require("sdk/addon/installer").uninstall(id);
</span>}
</pre><h1>lib/indexed-db-17.js (91%)</h1>

<pre>/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

<span class="pass" data-count="1"><span class="count">1</span>'use strict';
</span>
<span class="pass" data-count="1"><span class="count">1</span>module.metadata = {
  "stability": "experimental"
};
</span>
<span class="pass" data-count="1"><span class="count">1</span>const { Cc, Ci } = require('chrome');
</span><span class="pass" data-count="1"><span class="count">1</span>const { id } = require('self');
</span>
// Injects `indexedDB` to `this` scope.
<span class="pass" data-count="1"><span class="count">1</span>Cc["@mozilla.org/dom/indexeddb/manager;1"].
getService(Ci.nsIIndexedDatabaseManager).
initWindowless(this);
</span>
// Firefox 14 gets this with a prefix
<span class="pass" data-count="1"><span class="count">1</span>if (typeof(indexedDB) === "undefined")
  this.indexedDB = mozIndexedDB;
</span>
// Wrap `indexedDB` methods in order to prefix names
// with add-on IDs. This is temporary workaround for
// Bug 786688. Note: once bug is fixed and prefixing is
// removed existing DBs will appear non-existing.
<span class="pass" data-count="1"><span class="count">1</span>function prefixWrapper(method) {
  <span class="pass" data-count="2"><span class="count">2</span>return function(name) {
    <span class="error" data-count="0"><span class="count">0</span>let args = [ id + ':' + name ].concat(Array.slice(arguments, 1));
</span>    <span class="error" data-count="0"><span class="count">0</span>return method.apply(indexedDB, args);
</span>  }
}</span>
</span><span class="pass" data-count="1"><span class="count">1</span>exports.indexedDB = Object.create(indexedDB, {
  open: { value: prefixWrapper(indexedDB.open) },
  deleteDatabase: { value: prefixWrapper(indexedDB.deleteDatabase) }
});
</span><span class="pass" data-count="1"><span class="count">1</span>exports.IDBKeyRange = IDBKeyRange;
</span><span class="pass" data-count="1"><span class="count">1</span>exports.DOMException = Ci.nsIDOMDOMException;
</span><span class="pass" data-count="1"><span class="count">1</span>exports.IDBCursor = Ci.nsIIDBCursor;
</span><span class="pass" data-count="1"><span class="count">1</span>exports.IDBTransaction = Ci.nsIIDBTransaction;
</span><span class="pass" data-count="1"><span class="count">1</span>exports.IDBOpenDBRequest = Ci.nsIIDBOpenDBRequest;
</span><span class="pass" data-count="1"><span class="count">1</span>exports.IDBVersionChangeEvent = Ci.nsIIDBVersionChangeEvent;
</span><span class="pass" data-count="1"><span class="count">1</span>exports.IDBDatabase = Ci.nsIIDBDatabase;
</span><span class="pass" data-count="1"><span class="count">1</span>exports.IDBFactory = Ci.nsIIDBFactory;
</span><span class="pass" data-count="1"><span class="count">1</span>exports.IDBIndex = Ci.nsIIDBIndex;
</span><span class="pass" data-count="1"><span class="count">1</span>exports.IDBObjectStore = Ci.nsIIDBObjectStore;
</span><span class="pass" data-count="1"><span class="count">1</span>exports.IDBRequest = Ci.nsIIDBRequest;
</pre>
</body>
</html>
