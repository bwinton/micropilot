<head>
  <script>
    var raw = [{"id":"0-1361648350216","name":"main","description":{"full":"<p>Example Usage for module:</p>\n\n<p>Usage:</p>\n\n<div class=\"highlight\"><pre lang=\"\"> Micropilot('mystudy').start().record({'a':1}).then(function(mtp){\n   mtp.upload(UPLOAD_URL + mtp.studyid);\n })\n</pre></div>\n\n<p>record <code>{a:1, ts: Date.now()}</code>.  Then upload.</p>\n\n<div class=\"highlight\"><pre lang=\"\">require('micropilot').Micropilot('simplestudyid').start().\n   record({a:1,ts: Date.now()}).then(function(m) m.ezupload())\n   // which actually uploads!\n</pre></div>\n\n<p>For 1 day, record any data notified on <code>Observer</code> topics <code>['topic1', 'topic2']</code><br />then upload to <code>&lt;url&gt;</code>, after that 24 hour <code>Fuse</code> completes.</p>\n\n<div class=\"highlight\"><pre lang=\"\">require(\"micropilot\").Micropilot('otherstudyid').start().watch(['topic1','topic2']).\n  lifetime(24 * 60 * 60 * 1000).then(\n    function(mtp){ mtp.upload(url); mtp.stop() })\n</pre></div>\n\n<p>How a more realistic study might look.</p>\n\n<div class=\"highlight\"><pre lang=\"\">let monitor_tabopen = require('micropilot').Micropilot('tapopenstudy');\nvar tabs = require('tabs');\ntabs.on('ready', function () {\n  monitor_tabopen.record({'msg:' 'tab ready', 'ts': Date.now()})\n});\n\nmonitor_tabopen.lifetime(86400*1000).then(function(mon){mon.ezupload()});\n  // Fuse:  24 hours-ish after first start, upload\n\nif (user_tells_us_to_stop_snooping){\n  monitor_tabopen.stop();\n}\n</pre></div>","summary":"<p>Example Usage for module:</p>","body":"<p>Usage:</p>\n\n<div class=\"highlight\"><pre lang=\"\"> Micropilot('mystudy').start().record({'a':1}).then(function(mtp){\n   mtp.upload(UPLOAD_URL + mtp.studyid);\n })\n</pre></div>\n\n<p>record <code>{a:1, ts: Date.now()}</code>.  Then upload.</p>\n\n<div class=\"highlight\"><pre lang=\"\">require('micropilot').Micropilot('simplestudyid').start().\n   record({a:1,ts: Date.now()}).then(function(m) m.ezupload())\n   // which actually uploads!\n</pre></div>\n\n<p>For 1 day, record any data notified on <code>Observer</code> topics <code>['topic1', 'topic2']</code><br />then upload to <code>&lt;url&gt;</code>, after that 24 hour <code>Fuse</code> completes.</p>\n\n<div class=\"highlight\"><pre lang=\"\">require(\"micropilot\").Micropilot('otherstudyid').start().watch(['topic1','topic2']).\n  lifetime(24 * 60 * 60 * 1000).then(\n    function(mtp){ mtp.upload(url); mtp.stop() })\n</pre></div>\n\n<p>How a more realistic study might look.</p>\n\n<div class=\"highlight\"><pre lang=\"\">let monitor_tabopen = require('micropilot').Micropilot('tapopenstudy');\nvar tabs = require('tabs');\ntabs.on('ready', function () {\n  monitor_tabopen.record({'msg:' 'tab ready', 'ts': Date.now()})\n});\n\nmonitor_tabopen.lifetime(86400*1000).then(function(mon){mon.ezupload()});\n  // Fuse:  24 hours-ish after first start, upload\n\nif (user_tells_us_to_stop_snooping){\n  monitor_tabopen.stop();\n}\n</pre></div>"},"full_description":"<p>Example Usage for module:</p>\n\n<p>Usage:</p>\n\n<div class=\"highlight\"><pre lang=\"\"> Micropilot('mystudy').start().record({'a':1}).then(function(mtp){\n   mtp.upload(UPLOAD_URL + mtp.studyid);\n })\n</pre></div>\n\n<p>record <code>{a:1, ts: Date.now()}</code>.  Then upload.</p>\n\n<div class=\"highlight\"><pre lang=\"\">require('micropilot').Micropilot('simplestudyid').start().\n   record({a:1,ts: Date.now()}).then(function(m) m.ezupload())\n   // which actually uploads!\n</pre></div>\n\n<p>For 1 day, record any data notified on <code>Observer</code> topics <code>['topic1', 'topic2']</code> then upload to <code>&lt;url&gt;</code>, after that 24 hour <code>Fuse</code> completes.</p>\n\n<div class=\"highlight\"><pre lang=\"\">require(\"micropilot\").Micropilot('otherstudyid').start().watch(['topic1','topic2']).\n  lifetime(24 * 60 * 60 * 1000).then(\n    function(mtp){ mtp.upload(url); mtp.stop() })\n</pre></div>\n\n<p>How a more realistic study might look.</p>\n\n<div class=\"highlight\"><pre lang=\"\">let monitor_tabopen = require('micropilot').Micropilot('tapopenstudy');\nvar tabs = require('tabs');\ntabs.on('ready', function () {\n  monitor_tabopen.record({'msg:' 'tab ready', 'ts': Date.now()})\n});\n\nmonitor_tabopen.lifetime(86400*1000).then(function(mon){mon.ezupload()});\n  // Fuse:  24 hours-ish after first start, upload\n\nif (user_tells_us_to_stop_snooping){\n  monitor_tabopen.stop();\n}\n</pre></div>","params":[],"has_params":false,"tags":[{"type":"module","string":"main"}],"module":true,"related":{"href":""},"has_related":true,"methods":[{"id":"2-1361648350216","name":"requireAny","signiture":"requireAny()","type":"function","ctx":{"type":"function","name":"requireAny","string":"requireAny()"},"description":{"full":"<p>Return first-successful reqiured module from a list of paths</p>","summary":"<p>Return first-successful reqiured module from a list of paths</p>","body":""},"full_description":"<p>Return first-successful reqiured module from a list of paths</p>","code":"function requireAny(paths,msg) {\n  msg = msg ||  \"No such module\";\n  // path of paths\n  for (let i = 0, ii = paths.length; i < ii; i++) {\n    try {\n      return require(paths[i]);\n    } catch (e) {\n      console.log(e);\n    }\n  } throw msg;\n};","params":[{"type":"param","types":["Array"],"name":"paths","description":"strings of module paths to try"},{"type":"param","types":["string"],"name":"msg","description":"throw message on failure of all paths (default: \"No such module\")"}],"has_params":true,"tags":[{"type":"return","types":["object"],"description":"required module"},{"type":"","string":""},{"type":"param","types":["Array"],"name":"paths","description":"strings of module paths to try"},{"type":"param","types":["string"],"name":"msg","description":"throw message on failure of all paths (default: \"No such module\")"},{"type":"","string":""},{"type":"memberOf","parent":"main"},{"type":"name","string":"requireAny"}],"module":false,"parent":"main","related":{"href":""},"has_related":true},{"id":"3-1361648350217","name":"uu","description":{"full":"<p>Random UUID as string, without braces.</p>","summary":"<p>Random UUID as string, without braces.</p>","body":""},"full_description":"<p>Random UUID as string, without braces.</p>","code":"let uu = exports.uu = function(){\n        return uuid().number.slice(1,-1)\n};","params":[],"has_params":false,"tags":[{"type":"return","types":["string"],"description":"random uuid without braces"},{"type":"","string":""},{"type":"memberOf","parent":"main"},{"type":"name","string":"uu"}],"module":false,"parent":"main","related":{"href":""},"has_related":true},{"id":"4-1361648350217","name":"GOODSTATUS","description":{"full":"<p>Object with \"passing\" HTTP status codes.</p>","summary":"<p>Object with \"passing\" HTTP status codes.</p>","body":""},"full_description":"<p>Object with \"passing\" HTTP status codes.</p>","code":"const GOODSTATUS = exports.GOODSTATUS = {\n  //\"O\": 0,\n  \"200\": 200,\n  \"201\": 201,\n  \"202\": 202,\n  \"203\": 203,\n  \"204\": 204\n};","params":[],"has_params":false,"tags":[{"type":"memberOf","parent":"main"},{"type":"name","string":"GOODSTATUS"}],"module":false,"parent":"main","related":{"href":""},"has_related":true},{"id":"5-1361648350217","name":"UPLOAD_URL","description":{"full":"<p>Upload url</p>","summary":"<p>Upload url</p>","body":""},"full_description":"<p>Upload url</p>","code":"let UPLOAD_URL = exports.UPLOAD_URL = \"https://testpilot.mozillalabs.com/submit/testpilot_micropilot_\";","params":[],"has_params":false,"tags":[{"type":"memberOf","parent":"main"},{"type":"name","string":"UPLOAD_URL"}],"module":false,"parent":"main","related":{"href":""},"has_related":true},{"id":"7-1361648350217","name":"requestError","description":{"full":"<p>common generic function to handle request errors</p>\n\n<p>Console errors the error code.</p>","summary":"<p>common generic function to handle request errors</p>","body":"<p>Console errors the error code.</p>"},"full_description":"<p>common generic function to handle request errors</p>\n\n<p>Console errors the error code.</p>","code":"let requestError = function(evt) console.error(\"ERROR\",evt.target.errorCode);\nlet requestBlocked = function(evt) console.log(\"BLOCKED\",evt);","params":[],"has_params":false,"tags":[{"type":"memberOf","parent":"main"},{"type":"name","string":"requestError"}],"module":false,"parent":"main","related":{"href":""},"has_related":true},{"id":"30-1361648350219","name":"snoop","description":{"full":"<p>gather general user data, including addons, os, etc.</p>\n\n<p>Properties:  appname, location, fxVersion, os, updateChannel, addons list</p>","summary":"<p>gather general user data, including addons, os, etc.</p>","body":"<p>Properties:  appname, location, fxVersion, os, updateChannel, addons list</p>"},"full_description":"<p>gather general user data, including addons, os, etc.</p>\n\n<p>Properties:  appname, location, fxVersion, os, updateChannel, addons list</p>","code":"let snoop = exports.snoop = function(){\n  let { promise, resolve } = defer();\n  let LOCALE_PREF = \"general.useragent.locale\";\n  let UPDATE_CHANNEL_PREF = \"app.update.channel\";\n  let xa = require(\"xul-app\");\n  let prefs = require('preferences-service');\n\n  let u = {};\n  u.appname = xa.name;\n  u.location = prefs.get(LOCALE_PREF)\n  u.fxVersion = xa.version;\n  u.os = require('runtime').os;\n  u.updateChannel = prefs.get(UPDATE_CHANNEL_PREF)\n\n  let { AddonManager } = Cu.import(\"resource://gre/modules/AddonManager.jsm\");\n  u.addons = [];\n  AddonManager.getAllAddons(function(addonList){\n    Array.forEach(addonList,function(a){\n      let o = {};\n      ['id','name','appDisabled','isActive','type','userDisabled'].forEach(function(k){\n        o[k] = a[k]\n      })\n      u.addons.push(o);\n    })\n    resolve(u);\n  })\n  return promise;\n}","params":[],"has_params":false,"tags":[{"type":"return","types":["promise"],"description":"promise of userdata"},{"type":"name","string":"snoop"},{"type":"memberOf","parent":"main"}],"module":false,"parent":"main","related":{"href":""},"has_related":true},{"id":"35-1361648350219","name":"killaddon","description":{"full":"<p>Self-destruct (uninstall) this addon</p>","summary":"<p>Self-destruct (uninstall) this addon</p>","body":""},"full_description":"<p>Self-destruct (uninstall) this addon</p>","code":"let killaddon = exports.killaddon = function(){\n  let id = require('self').id;\n  microlog(\"attempting to remove addon:\", id);\n  require(\"sdk/addon/installer\").uninstall(id);\n}","params":[],"has_params":false,"tags":[{"type":"memberOf","parent":"main"},{"type":"name","string":"killaddon"}],"module":false,"parent":"main","related":{"href":""},"has_related":true}]},{"id":"9-1361648350217","name":"EventStore","description":{"full":"<p>EventStore Constructor (Heritage)</p>","summary":"<p>EventStore Constructor (Heritage)</p>","body":""},"full_description":"<p>EventStore Constructor (Heritage)</p>","code":"let EventStore = exports.EventStore = Class({","params":[],"has_params":false,"tags":[{"type":"module","string":"EventStore"}],"module":true,"related":{"href":""},"has_related":true,"methods":[{"id":"10-1361648350217","name":"initialize","description":{"full":"<p>Create an event store.</p>","summary":"<p>Create an event store.</p>","body":""},"full_description":"<p>Create an event store.</p>","code":"initialize: function(collection,keyname){\n    this.collection = collection;\n    this.keyname = keyname || \"eventstoreid\";\n  },\n  type: \"EventStore\",","params":[{"type":"param","types":["string"],"name":"collection","description":"used in db and objectStore names."},{"type":"param","types":["string"],"name":"key","description":"autoincrement key, (default: \"eventstoreid\")"}],"has_params":true,"tags":[{"type":"param","types":["string"],"name":"collection","description":"used in db and objectStore names."},{"type":"param","types":["string"],"name":"key","description":"autoincrement key, (default: \"eventstoreid\")"},{"type":"","string":""},{"type":"return","types":["EventStore"],"description":"instance"},{"type":"memberOf","parent":"EventStore"},{"type":"name","string":"initialize"}],"module":false,"parent":"EventStore","related":{"href":""},"has_related":true},{"id":"11-1361648350217","name":"db","description":{"full":"<p>promise a indexedDB connection to <code>\"micropilot-\"+this.collection</code>.</p>\n\n<p>If first connection to db, creates object store:</p>\n\n<p><code>createObjectStore(that.collection,{keyPath: that.keyname, autoIncrement: true }</code></p>\n\n<p>Resolves on success with (<code>request.result</code>)</p>","summary":"<p>promise a indexedDB connection to <code>\"micropilot-\"+this.collection</code>.</p>","body":"<p>If first connection to db, creates object store:</p>\n\n<p><code>createObjectStore(that.collection,{keyPath: that.keyname, autoIncrement: true }</code></p>\n\n<p>Resolves on success with (<code>request.result</code>)</p>"},"full_description":"<p>promise a indexedDB connection to <code>\"micropilot-\"+this.collection</code>.</p>\n\n<p>If first connection to db, creates object store:</p>\n\n<p><code>createObjectStore(that.collection,{keyPath: that.keyname, autoIncrement: true }</code></p>\n\n<p>Resolves on success with (<code>request.result</code>)</p>","code":"db: function(){\n    let that = this;\n    let {promise, resolve} = defer();\n    // TODO each EventStore has different Db, so the createObjectStore will work.  Is this gross?\n    let req = indexedDB.open(\"micropilot-\"+that.collection,1);\n    req.onerror = requestError;\n    req.onupgradeneeded = function (event) {\n      let objectStore = req.result.createObjectStore(that.collection,\n        {keyPath: that.keyname, autoIncrement: true });\n      microlog(\"micropilot-object-store-made:\", that.collection )\n    };\n    // called after onupgradeneeded\n    req.onsuccess = function(event) {\n      resolve(req.result);\n    };\n    req.onblocked = requestBlocked;\n\n    return promise\n  },","params":[],"has_params":false,"tags":[{"type":"memberOf","parent":"EventStore"},{"type":"name","string":"db"},{"type":"return","types":["promise"],"description":""}],"module":false,"parent":"EventStore","related":{"href":""},"has_related":true},{"id":"12-1361648350217","name":"add","description":{"full":"<p>promises to add data to the autoincrementing objectStore.</p>\n\n<p>Resolves on success with (<code>{id: newkey, data:data}</code>)</p>","summary":"<p>promises to add data to the autoincrementing objectStore.</p>","body":"<p>Resolves on success with (<code>{id: newkey, data:data}</code>)</p>"},"full_description":"<p>promises to add data to the autoincrementing objectStore.</p>\n\n<p>Resolves on success with (<code>{id: newkey, data:data}</code>)</p>","code":"add: function(data){\n    let that = this;\n    let {promise, resolve} = defer();\n    this.db().then(function(db){\n      let req = db.transaction([that.collection], \"readwrite\").\n        objectStore(that.collection).add(data);\n      req.onsuccess = function (evt) {\n        let newkey = evt.target.result;\n        resolve({id: newkey, data:data});\n      };\n      req.onerror = requestError;\n      req.onblocked = requestBlocked;\n\n    })\n    return promise\n  },","params":[{"type":"param","types":["object"],"name":"data","description":"jsonable data"}],"has_params":true,"tags":[{"type":"param","types":["object"],"name":"data","description":"jsonable data"},{"type":"","string":""},{"type":"memberOf","parent":"EventStore"},{"type":"name","string":"add"},{"type":"return","types":["promise"],"description":""}],"module":false,"parent":"EventStore","related":{"href":""},"has_related":true},{"id":"14-1361648350217","name":"clear","description":{"full":"<p>promise to drop the database.</p>\n\n<p>Resolves onsuccess (<code>request.result</code>)</p>","summary":"<p>promise to drop the database.</p>","body":"<p>Resolves onsuccess (<code>request.result</code>)</p>"},"full_description":"<p>promise to drop the database.</p>\n\n<p>Resolves onsuccess (<code>request.result</code>)</p>","code":"clear: function(){\n    let that = this;\n    let {promise, resolve} = defer();\n    let req = indexedDB.deleteDatabase(\"micropilot-\"+that.collection,1);\n    req.onsuccess = function(event) {\n      resolve(req.result);\n    }\n    req.onerror = requestError;\n    req.onblocked = requestBlocked;\n    return promise;\n  }\n});","params":[],"has_params":false,"tags":[{"type":"memberOf","parent":"EventStore"},{"type":"name","string":"clear"},{"type":"return","types":["promise"],"description":""}],"module":false,"parent":"EventStore","related":{"href":""},"has_related":true}]},{"id":"15-1361648350217","name":"Micropilot","description":{"full":"<p>Micropilot Heritage Object</p>\n\n<p>Persists over multiple runs.<br />(Persistence achieved using <code>simple-store</code>, which ties a Micropilot into<br />a particular addon)</p>","summary":"<p>Micropilot Heritage Object</p>","body":"<p>Persists over multiple runs.<br />(Persistence achieved using <code>simple-store</code>, which ties a Micropilot into<br />a particular addon)</p>"},"full_description":"<p>Micropilot Heritage Object</p>\n\n<p>Persists over multiple runs. (Persistence achieved using <code>simple-store</code>, which ties a Micropilot into a particular addon)</p>","code":"let Micropilot = exports.Micropilot = Class({","params":[{"type":"param","types":["string"],"name":"studyid","description":"unique key to id the study (used by dbs, prefs)"}],"has_params":true,"tags":[{"type":"param","types":["string"],"name":"studyid","description":"unique key to id the study (used by dbs, prefs)"},{"type":"module","string":"Micropilot"},{"type":"","string":""},{"type":"returns","string":"Micropilot instance"}],"module":true,"related":{"href":""},"has_related":true,"methods":[{"id":"16-1361648350217","name":"initialize","description":{"full":"<p>Initialize the Micropilot</p>\n\n<p>internals:</p>\n\n<ul>\n<li><code>_watched</code>: observed topics</li>\n<li><code>eventstore</code>: an EventStore</li>\n<li><code>_config</code>: simple-store configuration\n<ul><li><code>personid</code>:  a <code>uu()</code>  (set this if you want.)</li>\n<li><code>_startdate</code>:  now, or then (if revived)</li></ul></li>\n<li><code>willrecord</code>:  a brake on event recording</li>\n</ul>","summary":"<p>Initialize the Micropilot</p>","body":"<p>internals:</p>\n\n<ul>\n<li><code>_watched</code>: observed topics</li>\n<li><code>eventstore</code>: an EventStore</li>\n<li><code>_config</code>: simple-store configuration\n<ul><li><code>personid</code>:  a <code>uu()</code>  (set this if you want.)</li>\n<li><code>_startdate</code>:  now, or then (if revived)</li></ul></li>\n<li><code>willrecord</code>:  a brake on event recording</li>\n</ul>"},"full_description":"<p>Initialize the Micropilot</p>\n\n<p>internals:</p>\n\n<ul>\n<li><code>_watched</code>: observed topics</li>\n<li><code>eventstore</code>: an EventStore</li>\n<li><code>_config</code>: simple-store configuration\n<ul><li><code>personid</code>:  a <code>uu()</code>  (set this if you want.)</li>\n<li><code>_startdate</code>:  now, or then (if revived)</li></ul></li>\n<li><code>willrecord</code>:  a brake on event recording</li>\n</ul>","code":"initialize: function(studyid){\n      // setup the indexdb\n      this.studyid = studyid;\n      this._watched = {};\n      this.eventstore = EventStore(this.studyid);\n      this._config = storage.micropilot[studyid]; // persists\n      if (this._config === undefined) {\n        this._config = {};\n        this._config.personid = uu();\n      }\n      this._startdate = this._config.startdate = Date.now(); // start now\n      this.willrecord = false; // won't record.\n  },\n  type: 'Micropilot',","params":[{"type":"param","types":["String"],"name":"studyid","description":"Id for persistent store, db."}],"has_params":true,"tags":[{"type":"memberOf","parent":"Micropilot"},{"type":"name","string":"initialize"},{"type":"param","types":["String"],"name":"studyid","description":"Id for persistent store, db."}],"module":false,"parent":"Micropilot","related":{"href":""},"has_related":true},{"id":"17-1361648350217","name":"startdate","description":{"full":"<p>get and set the startDate</p>","summary":"<p>get and set the startDate</p>","body":""},"full_description":"<p>get and set the startDate</p>","code":"get startdate() this._startdate,\n  // resetting the startdate kills existing lifetime / fuse\n  set startdate(ts) {\n    this.stop();\n    this._startdate = ts;\n  },","params":[],"has_params":false,"tags":[{"type":"memberOf","parent":"Micropilot"},{"type":"name","string":"startdate"}],"module":false,"parent":"Micropilot","related":{"href":""},"has_related":true},{"id":"18-1361648350218","name":"data","description":{"full":"<p>promise of all recorded event data</p>\n\n<p>Resolve (<code>data</code>)</p>","summary":"<p>promise of all recorded event data</p>","body":"<p>Resolve (<code>data</code>)</p>"},"full_description":"<p>promise of all recorded event data</p>\n\n<p>Resolve (<code>data</code>)</p>","code":"data: function() this.eventstore.getAll(),","params":[],"has_params":false,"tags":[{"type":"memberOf","parent":"Micropilot"},{"type":"name","string":"data"},{"type":"return","types":["promise"],"description":""}],"module":false,"parent":"Micropilot","related":{"href":""},"has_related":true},{"id":"19-1361648350218","name":"clear","description":{"full":"<p>promise to clear all data (by dropping the db)</p>\n\n<p>Resolve(<code>request.response</code>) // of the dropDatabse</p>","summary":"<p>promise to clear all data (by dropping the db)</p>","body":"<p>Resolve(<code>request.response</code>) // of the dropDatabse</p>"},"full_description":"<p>promise to clear all data (by dropping the db)</p>\n\n<p>Resolve(<code>request.response</code>) // of the dropDatabse</p>","code":"clear: function() this.eventstore.clear(),","params":[],"has_params":false,"tags":[{"type":"memberOf","parent":"Micropilot"},{"type":"name","string":"clear"},{"type":"return","types":["promise"],"description":""}],"module":false,"parent":"Micropilot","related":{"href":""},"has_related":true},{"id":"20-1361648350218","name":"record","description":{"full":"<p>promise of <code>EventStore.add</code>, which is {id:&lt;>,data:&lt;>}<br />unless record \"doesn't happen\" because of non-running</p>","summary":"<p>promise of <code>EventStore.add</code>, which is {id:&lt;>,data:&lt;>}<br />unless record \"doesn't happen\" because of non-running</p>","body":""},"full_description":"<p>promise of <code>EventStore.add</code>, which is {id:&lt;>,data:&lt;>} unless record \"doesn't happen\" because of non-running</p>","code":"record: function(data){\n    // remember, `resolve` turns values into promises, and is noop on promises\n    if (! this.willrecord) return resolve(undefined);\n\n    // todo, what if it's not jsonable?\n    JSON.stringify(data);\n    microlog(\"micropilot-record:\", JSON.stringify(data));\n    return this.eventstore.add(data)\n  },","params":[],"has_params":false,"tags":[{"type":"memberOf","parent":"Micropilot"},{"type":"name","string":"record"},{"type":"return","types":["promise"],"description":""}],"module":false,"parent":"Micropilot","related":{"href":""},"has_related":true},{"id":"21-1361648350218","name":"lifetime","description":{"full":"<p>promise the study (setting a Fuse)</p>\n\n<p>Fuse set as {start: this.startdate,duration:duration}<br />(modify startdate to 'run from some other time')</p>\n\n<p>False or Undefined duration subls forever / never resolves</p>\n\n<p>Note:  calls <code>stop()</code> and <code>start()</code> as side-effects</p>\n\n<p>Resolves when the study fuse resolves.</p>\n\n<p>example:</p>\n\n<p><code>Micropilot('mystudy').lifetime(1000).then(function(mtp){mtp.stop()})</code></p>","summary":"<p>promise the study (setting a Fuse)</p>","body":"<p>Fuse set as {start: this.startdate,duration:duration}<br />(modify startdate to 'run from some other time')</p>\n\n<p>False or Undefined duration subls forever / never resolves</p>\n\n<p>Note:  calls <code>stop()</code> and <code>start()</code> as side-effects</p>\n\n<p>Resolves when the study fuse resolves.</p>\n\n<p>example:</p>\n\n<p><code>Micropilot('mystudy').lifetime(1000).then(function(mtp){mtp.stop()})</code></p>"},"full_description":"<p>promise the study (setting a Fuse)</p>\n\n<p>Fuse set as {start: this.startdate,duration:duration} (modify startdate to 'run from some other time')</p>\n\n<p>False or Undefined duration subls forever / never resolves</p>\n\n<p>Note:  calls <code>stop()</code> and <code>start()</code> as side-effects</p>\n\n<p>Resolves when the study fuse resolves.</p>\n\n<p>example:</p>\n\n<p><code>Micropilot('mystudy').lifetime(1000).then(function(mtp){mtp.stop()})</code></p>","code":"lifetime:  function(duration){\n    this.stop();\n    this.willrecord = true; // restart!\n    let deferred = defer();\n    let that = this;\n    // iff!\n    if (duration){\n      // should this allow / mix all fuse options?\n      this.fuse = Fuse({start: this.startdate,duration:duration, resolve_this: that});\n      return this.fuse;\n    } else {\n      // no duration, so infinite, so nothing to resolve.\n    }\n    this.start();\n    return deferred.promise;\n  },","params":[{"type":"param","types":["integer"],"name":"duration","description":"milliseconds to run Fuse"}],"has_params":true,"tags":[{"type":"param","types":["integer"],"name":"duration","description":"milliseconds to run Fuse"},{"type":"memberOf","parent":"Micropilot"},{"type":"name","string":"lifetime"},{"type":"return","types":["promise"],"description":""}],"module":false,"parent":"Micropilot","related":{"href":""},"has_related":true},{"id":"22-1361648350218","name":"start","description":{"full":"<p>allow record (<code>this.willrecord</code> -> <code>true</code>)</p>","summary":"<p>allow record (<code>this.willrecord</code> -> <code>true</code>)</p>","body":""},"full_description":"<p>allow record (<code>this.willrecord</code> -> <code>true</code>)</p>","code":"start:  function(){\n    this.willrecord = true;\n    return this;\n  },","params":[],"has_params":false,"tags":[{"type":"return","types":["micropilot"],"description":"this"},{"type":"memberOf","parent":"Micropilot"},{"type":"name","string":"start"}],"module":false,"parent":"Micropilot","related":{"href":""},"has_related":true},{"id":"23-1361648350218","name":"stop","description":{"full":"<p>stop the study (unset the fuse, <code>this.willrecord</code> -> <code>false</code>)</p>\n\n<p>(after stopping, <code>record</code> will not work, unless one <code>start()</code> or<br />or <code>willrecord</code> -> <code>true</code>)</p>","summary":"<p>stop the study (unset the fuse, <code>this.willrecord</code> -> <code>false</code>)</p>","body":"<p>(after stopping, <code>record</code> will not work, unless one <code>start()</code> or<br />or <code>willrecord</code> -> <code>true</code>)</p>"},"full_description":"<p>stop the study (unset the fuse, <code>this.willrecord</code> -> <code>false</code>)</p>\n\n<p>(after stopping, <code>record</code> will not work, unless one <code>start()</code> or or <code>willrecord</code> -> <code>true</code>)</p>","code":"stop:  function(){\n    this.willrecord = false;\n    this.fuse !== undefined && this.fuse.stop();\n    delete this.fuse;\n    return this;\n  },","params":[],"has_params":false,"tags":[{"type":"return","types":["micropilot"],"description":"this"},{"type":"memberOf","parent":"Micropilot"},{"type":"name","string":"stop"}],"module":false,"parent":"Micropilot","related":{"href":""},"has_related":true},{"id":"24-1361648350219","name":"_watch","description":{"full":"<p>(internal) watch a topic, add to <code>observer-service</code></p>","summary":"<p>(internal) watch a topic, add to <code>observer-service</code></p>","body":""},"full_description":"<p>(internal) watch a topic, add to <code>observer-service</code></p>","code":"_watch: function(topic){\n    if (this._watched[topic]) return\n\n    let that = this;\n    let cb;\n    if (this._watchfn !== undefined){\n      cb = function(subject) that._watchfn.call(that,topic,subject);\n    } else {\n      cb = function(subject) {that.record({\"msg\":topic,ts:Date.now(),\"data\":subject})};\n    }\n    let o = observer.add(topic,cb); // add to global watch list\n    this._watched[topic] = cb;\n  },","params":[{"type":"param","types":["string"],"name":"topic","description":"topic to watch."}],"has_params":true,"tags":[{"type":"param","types":["string"],"name":"topic","description":"topic to watch."},{"type":"memberOf","parent":"Micropilot"},{"type":"name","string":"_watch"},{"type":"return","types":["undefined"],"description":""}],"module":false,"parent":"Micropilot","related":{"href":""},"has_related":true},{"id":"25-1361648350219","name":"watch","description":{"full":"<p>add topics to watch (non-destructive)</p>","summary":"<p>add topics to watch (non-destructive)</p>","body":""},"full_description":"<p>add topics to watch (non-destructive)</p>","code":"watch: function(watch_list){\n      let that = this;\n      watch_list.forEach(function(t) that._watch(t))\n      return this;\n  },","params":[{"type":"param","types":["array"],"name":"watch_list","description":"list of topics"}],"has_params":true,"tags":[{"type":"param","types":["array"],"name":"watch_list","description":"list of topics"},{"type":"return","types":["micropilot"],"description":"this"},{"type":"memberOf","parent":"Micropilot"},{"type":"name","string":"watch"}],"module":false,"parent":"Micropilot","related":{"href":""},"has_related":true},{"id":"26-1361648350219","name":"_unwatch","description":{"full":"<p>(internal) stop watching topic</p>","summary":"<p>(internal) stop watching topic</p>","body":""},"full_description":"<p>(internal) stop watching topic</p>","code":"_unwatch: function(topic){\n    let cb = this._watched[topic];\n    cb && observer.remove(topic,cb);\n    delete this._watched[topic];\n  },","params":[],"has_params":false,"tags":[{"type":"memberOf","parent":"Micropilot"},{"type":"name","string":"_unwatch"},{"type":"return","types":["undefined"],"description":""}],"module":false,"parent":"Micropilot","related":{"href":""},"has_related":true},{"id":"27-1361648350219","name":"unwatch","description":{"full":"<p>unwatch some topics (destructive)<br />if <code>unwatch_list</code> is undefined, unwatch all.</p>","summary":"<p>unwatch some topics (destructive)<br />if <code>unwatch_list</code> is undefined, unwatch all.</p>","body":""},"full_description":"<p>unwatch some topics (destructive) if <code>unwatch_list</code> is undefined, unwatch all.</p>","code":"unwatch: function(unwatch_list){\n    if (unwatch_list === undefined) unwatch_list = Object.keys(this._watched);\n    let that = this;\n    unwatch_list.forEach(function(t) that._unwatch(t));\n    return this;\n  },","params":[{"type":"param","types":["array"],"name":"unwatch_list","description":"list of topics to remove. If undefined, unwatch all."}],"has_params":true,"tags":[{"type":"param","types":["array"],"name":"unwatch_list","description":"list of topics to remove. If undefined, unwatch all."},{"type":"memberOf","parent":"Micropilot"},{"type":"name","string":"unwatch"},{"type":"return","types":["micropilot"],"description":"this"}],"module":false,"parent":"Micropilot","related":{"href":""},"has_related":true},{"id":"28-1361648350219","name":"ezupload","description":{"full":"<p>promise simplified upload with strong opinions and retry semantics</p>\n\n<p>Options:</p>\n\n<ul>\n<li><code>url</code>:  defaults to <code>UPLOAD_URL + mtp.studyname</code></li>\n<li><code>maxtries</code>:  Number of tries.  (<code>3</code>)</li>\n<li><code>interval</code>:  How long to wait between tries (60 min - <code>60*60*1000</code>)</li>\n<li><code>killaddon</code>:  Should the addon delete itself on completion? (<code>false</code>)</li>\n</ul>\n\n<p><em>Note 1</em>:  <a href='https://github.com/gregglind/micropilot/issues/2'>https://github.com/gregglind/micropilot/issues/2</a></p>\n\n<p><em>Note 2</em>:  <code>_config.completed</code> will will go to <code>true</code> on success or not.</p>\n\n<p><em>Note 3</em>:  Adds some keys to <code>_config</code> persistence:</p>\n\n<ul>\n<li><code>completed</code></li>\n<li><code>uploadcounter</code></li>\n</ul>\n\n<p>This is Subject To Change, and just a starting point for how to talk<br />about study state.</p>","summary":"<p>promise simplified upload with strong opinions and retry semantics</p>","body":"<p>Options:</p>\n\n<ul>\n<li><code>url</code>:  defaults to <code>UPLOAD_URL + mtp.studyname</code></li>\n<li><code>maxtries</code>:  Number of tries.  (<code>3</code>)</li>\n<li><code>interval</code>:  How long to wait between tries (60 min - <code>60*60*1000</code>)</li>\n<li><code>killaddon</code>:  Should the addon delete itself on completion? (<code>false</code>)</li>\n</ul>\n\n<p><em>Note 1</em>:  <a href='https://github.com/gregglind/micropilot/issues/2'>https://github.com/gregglind/micropilot/issues/2</a></p>\n\n<p><em>Note 2</em>:  <code>_config.completed</code> will will go to <code>true</code> on success or not.</p>\n\n<p><em>Note 3</em>:  Adds some keys to <code>_config</code> persistence:</p>\n\n<ul>\n<li><code>completed</code></li>\n<li><code>uploadcounter</code></li>\n</ul>\n\n<p>This is Subject To Change, and just a starting point for how to talk<br />about study state.</p>"},"full_description":"<p>promise simplified upload with strong opinions and retry semantics</p>\n\n<p>Options:</p>\n\n<ul>\n<li><code>url</code>:  defaults to <code>UPLOAD_URL + mtp.studyname</code></li>\n<li><code>maxtries</code>:  Number of tries.  (<code>3</code>)</li>\n<li><code>interval</code>:  How long to wait between tries (60 min - <code>60*60*1000</code>)</li>\n<li><code>killaddon</code>:  Should the addon delete itself on completion? (<code>false</code>)</li>\n</ul>\n\n<p><em>Note 1</em>:  <a href='https://github.com/gregglind/micropilot/issues/2'>https://github.com/gregglind/micropilot/issues/2</a></p>\n\n<p><em>Note 2</em>:  <code>_config.completed</code> will will go to <code>true</code> on success or not.</p>\n\n<p><em>Note 3</em>:  Adds some keys to <code>_config</code> persistence:</p>\n\n<ul>\n<li><code>completed</code></li>\n<li><code>uploadcounter</code></li>\n</ul>\n\n<p>This is Subject To Change, and just a starting point for how to talk about study state.</p>","code":"ezupload: function(options){\n    let { promise, resolve } = defer();\n    let {url,maxtries,interval,killaddon:killpref} = options;\n    let that = this;\n    url = url || (UPLOAD_URL + that.studyid);\n    microlog(\"micropilot-ezupload:\",url );\n\n    maxtries = maxtries || 3\n    interval = interval || 60 * 60 * 1000; // 60 minutes\n\n    let mycleanup = function(){\n        that._config.completed = true ; // whatever properties you want\n        let p = that.stop();\n        p = that.clear();\n        if (killpref) {\n          microlog(\"micropilot: killpref on!\")\n          resolve(p.then(killaddon));   // stop the study, clear the data, uninstall the addon.\n        } else {\n          resolve(p)\n        }\n    }\n\n    if (this._config.uploadcounter === undefined) this._config.uploadcounter = 0;\n    let myupload = function() {\n      if (that._config.uploadcounter >= maxtries) { mycleanup(that); return};  // give up!\n      that._config.uploadcounter += 1;\n\n      that.upload(url).then(function(response){\n        if (! GOODSTATUS[response.status]) {  // try again in interval ms\n          microlog(\"micropilot-response-bad:\", response.status, \"retrying in:\", interval );\n          require('timers').setTimeout(function(){myupload()}, interval)\n        } else {\n          microlog(\"micropilot-ezupload-success\")\n          mycleanup();\n        }\n      })\n    }\n    myupload();\n    return promise;\n  },","params":[{"type":"param","types":["Object"],"name":"options","description":"Upload options."}],"has_params":true,"tags":[{"type":"param","types":["Object"],"name":"options","description":"Upload options."},{"type":"memberOf","parent":"Micropilot"},{"type":"name","string":"ezupload"},{"type":"return","types":["promise"],"description":""}],"module":false,"parent":"Micropilot","related":{"href":""},"has_related":true},{"id":"29-1361648350219","name":"upload","description":{"full":"<p>promise to upload the data</p>\n\n<p>Options:<br />- <code>simulate</code>:  don't post, promise the request<br />- <code>uploadid</code>:  an id for the upload</p>\n\n<p>Resolves<br />- if POST, after oncomplete (response)<br />- if <code>options.simulate</code> (request)</p>","summary":"<p>promise to upload the data</p>","body":"<p>Options:<br />- <code>simulate</code>:  don't post, promise the request<br />- <code>uploadid</code>:  an id for the upload</p>\n\n<p>Resolves<br />- if POST, after oncomplete (response)<br />- if <code>options.simulate</code> (request)</p>"},"full_description":"<p>promise to upload the data</p>\n\n<p>Options: - <code>simulate</code>:  don't post, promise the request - <code>uploadid</code>:  an id for the upload</p>\n\n<p>Resolves - if POST, after oncomplete (response) - if <code>options.simulate</code> (request)</p>","code":"upload:  function(url,options){\n    // get all... is this tangled between getting and posting?\n    // attempt to post\n    options = options===undefined ? {} : options;\n    let that = this;\n    let simulate = options.simulate;\n    let { promise, resolve } = defer();\n    let uploadid = options.uploadid || uu(); // specific to the upload\n    this.data().then(function(data){\n      microlog(\"micropilot-willupload-data:\", JSON.stringify(data));\n      let payload = {events:data};\n      payload.userdata = snoop();\n      payload.ts = Date.now();\n      payload.uploadid = uploadid;\n      payload.personid = that._config.personid;\n      snoop().then(function(userdata){\n        microlog(\"micropilot-willupload-content:\", JSON.stringify(payload));\n        payload.userdata = userdata;\n        let R = Request({\n          url: url,\n          headers: {\n          },\n          content: JSON.stringify(payload),\n          contentType: \"application/json\",\n\n          onComplete: function (response) {\n            microlog(\"micropilot-upload-response:\",response.status);\n            microlog(\"micropilot-upload-response:\",response.text);\n            resolve(response) },\n        });\n        if (simulate) {\n          resolve(R);\n        } else {\n          R.post();\n        }\n      })\n    });\n    return promise;\n  }\n\n});","params":[{"type":"param","types":["string"],"name":"url","description":"url to POST."},{"type":"param","types":["object"],"name":"options","description":"some options, below."}],"has_params":true,"tags":[{"type":"param","types":["string"],"name":"url","description":"url to POST."},{"type":"param","types":["object"],"name":"options","description":"some options, below."},{"type":"memberOf","parent":"Micropilot"},{"type":"name","string":"upload"},{"type":"return","types":["promise"],"description":""}],"module":false,"parent":"Micropilot","related":{"href":""},"has_related":true}]},{"id":"31-1361648350219","name":"Fuse","description":{"full":"<p>Fuse Heritage Class</p>","summary":"<p>Fuse Heritage Class</p>","body":""},"full_description":"<p>Fuse Heritage Class</p>","code":"let Fuse = exports.Fuse = Class({","params":[],"has_params":false,"tags":[{"type":"module","string":"Fuse"}],"module":true,"related":{"href":""},"has_related":true,"methods":[{"id":"32-1361648350219","name":"initialize","description":{"full":"<p>Fuses trigger (resolve their promise) no sooner than <code>duration + start</code></p>\n\n<p>(like a dynamite fuse)</p>\n\n<p>Options:</p>\n\n<ul>\n<li><code>start</code>:  start time for the fuse</li>\n<li><code>duration</code>: how long to run.</li>\n<li><code>pulseinterval</code>:  if defined, use a <code>setInterval</code> timer (see below)</li>\n<li><code>resolve_this</code>:  the <code>this</code> passed into the <code>then</code> during resolution (default undefined)</li>\n<li><code>pulsefn</code>:  if <code>setInterval</code> timer, run this function during every <code>pulse</code></li>\n</ul>\n\n<p><code>setInterval</code> vs. <code>setTimeout</code>:  Fuse is normally a <code>setTimeout</code>.  If you<br />want finer control over it (including being able to modify the timers of<br />running Fuses), use <code>pulseInterval</code> to make a <code>setInterval</code> timer.</p>\n\n<p>Note 1: \"Short Fuses\":  When the <code>duration</code> is very short, we don't guaranteed<br />millisecond accuracy!</p>\n\n<p>Note 2:  Restart.  If a Fuse 'should fire' while Firefox is not running,<br />it will fire the next time it can.</p>\n\n<p>Note 3:  Blast from the Past.  Fuses fire IFF</p>\n\n<p><div class=\"highlight\"><pre lang=\"\">  Date.now() >= (that.start + that.duration)<br />  </pre></div></p>\n\n<p>Note 4: Persist a fuse over restarts.</p>\n\n<div class=\"highlight\"><pre lang=\"\">  let {storage} = require(\"simple-storage\");\n  if (! storage.firststart) ss.firststart = Date.now(); // tied to addon\n  Fuse({start: storeage.firststart,duration:86400 * 7 * 1000 }).then(\n   function(){ Micropilot('delayedstudy').start()} )\n</pre></div>","summary":"<p>Fuses trigger (resolve their promise) no sooner than <code>duration + start</code></p>","body":"<p>(like a dynamite fuse)</p>\n\n<p>Options:</p>\n\n<ul>\n<li><code>start</code>:  start time for the fuse</li>\n<li><code>duration</code>: how long to run.</li>\n<li><code>pulseinterval</code>:  if defined, use a <code>setInterval</code> timer (see below)</li>\n<li><code>resolve_this</code>:  the <code>this</code> passed into the <code>then</code> during resolution (default undefined)</li>\n<li><code>pulsefn</code>:  if <code>setInterval</code> timer, run this function during every <code>pulse</code></li>\n</ul>\n\n<p><code>setInterval</code> vs. <code>setTimeout</code>:  Fuse is normally a <code>setTimeout</code>.  If you<br />want finer control over it (including being able to modify the timers of<br />running Fuses), use <code>pulseInterval</code> to make a <code>setInterval</code> timer.</p>\n\n<p>Note 1: \"Short Fuses\":  When the <code>duration</code> is very short, we don't guaranteed<br />millisecond accuracy!</p>\n\n<p>Note 2:  Restart.  If a Fuse 'should fire' while Firefox is not running,<br />it will fire the next time it can.</p>\n\n<p>Note 3:  Blast from the Past.  Fuses fire IFF</p>\n\n<p><div class=\"highlight\"><pre lang=\"\">  Date.now() >= (that.start + that.duration)<br />  </pre></div></p>\n\n<p>Note 4: Persist a fuse over restarts.</p>\n\n<div class=\"highlight\"><pre lang=\"\">  let {storage} = require(\"simple-storage\");\n  if (! storage.firststart) ss.firststart = Date.now(); // tied to addon\n  Fuse({start: storeage.firststart,duration:86400 * 7 * 1000 }).then(\n   function(){ Micropilot('delayedstudy').start()} )\n</pre></div>"},"full_description":"<p>Fuses trigger (resolve their promise) no sooner than <code>duration + start</code></p>\n\n<p>(like a dynamite fuse)</p>\n\n<p>Options:</p>\n\n<ul>\n<li><code>start</code>:  start time for the fuse</li>\n<li><code>duration</code>: how long to run.</li>\n<li><code>pulseinterval</code>:  if defined, use a <code>setInterval</code> timer (see below)</li>\n<li><code>resolve_this</code>:  the <code>this</code> passed into the <code>then</code> during resolution (default undefined)</li>\n<li><code>pulsefn</code>:  if <code>setInterval</code> timer, run this function during every <code>pulse</code></li>\n</ul>\n\n<p><code>setInterval</code> vs. <code>setTimeout</code>:  Fuse is normally a <code>setTimeout</code>.  If you want finer control over it (including being able to modify the timers of running Fuses), use <code>pulseInterval</code> to make a <code>setInterval</code> timer.</p>\n\n<p>Note 1: \"Short Fuses\":  When the <code>duration</code> is very short, we don't guaranteed millisecond accuracy!</p>\n\n<p>Note 2:  Restart.  If a Fuse 'should fire' while Firefox is not running, it will fire the next time it can.</p>\n\n<p>Note 3:  Blast from the Past.  Fuses fire IFF</p>\n\n<p><div class=\"highlight\"><pre lang=\"\">  Date.now() >= (that.start + that.duration)   </pre></div></p>\n\n<p>Note 4: Persist a fuse over restarts.</p>\n\n<div class=\"highlight\"><pre lang=\"\">  let {storage} = require(\"simple-storage\");\n  if (! storage.firststart) ss.firststart = Date.now(); // tied to addon\n  Fuse({start: storeage.firststart,duration:86400 * 7 * 1000 }).then(\n   function(){ Micropilot('delayedstudy').start()} )\n</pre></div>","code":"initialize: function(options){\n    let {start,duration,pulseinterval,resolve_this,pulsefn} = options;\n    this.pulseinterval =  pulseinterval;\n    let that = this;\n    this.start = start;\n    this.duration = duration;\n    let { promise, resolve } = defer();\n    this.promise = promise;\n    this.resolve = resolve;\n    // should this be setInterval, or setTimeout?\n    // setInterval allows one to modify the fuse while running\n    // more easily, but setTimeout is much more precise.\n    if (pulseinterval){\n      this.timerid = timers.setInterval(function(){\n        if (that.checking) {\n          return;  // prevent races\n        }\n        that.checking = true;\n        if (pulsefn) {pulsefn(that)}\n        if (! duration) return;\n        if (Date.now() >= (that.start + that.duration)){\n          that.resolve(resolve_this);\n          that.stop();\n        }\n        that.checking=false;\n      },pulseinterval);\n    } else {\n      // TODO, what is setTimeout on a negative?\n      that.checking=false;\n      let timerunningsofar = (Date.now() - this.start);\n      if (duration <= timerunningsofar) { // really short intervals\n        that.resolve(resolve_this);\n        this.stop();\n      } else {\n        this.timerid = timers.setTimeout(function(){\n          that.resolve(resolve_this);\n          that.stop();\n        }, duration - timerunningsofar);\n      }\n    }\n  },","params":[{"type":"param","types":["Object"],"name":"options","description":""}],"has_params":true,"tags":[{"type":"memberOf","parent":"Fuse"},{"type":"param","types":["Object"],"name":"options","description":""},{"type":"returns","string":"Fuse instance"},{"type":"name","string":"initialize"}],"module":false,"parent":"Fuse","related":{"href":""},"has_related":true},{"id":"33-1361648350219","name":"then","description":{"full":"<p>promise the promise.  Resolves with <code>resolve_this</code></p>","summary":"<p>promise the promise.  Resolves with <code>resolve_this</code></p>","body":""},"full_description":"<p>promise the promise.  Resolves with <code>resolve_this</code></p>","code":"get then() this.promise.then,\n\n  type: 'Fuse',","params":[],"has_params":false,"tags":[{"type":"memberOf","parent":"Fuse"},{"type":"name","string":"then"},{"type":"return","types":["promise"],"description":""}],"module":false,"parent":"Fuse","related":{"href":""},"has_related":true},{"id":"34-1361648350219","name":"stop","description":{"full":"<p>stop the fuse (clear the timeout).</p>","summary":"<p>stop the fuse (clear the timeout).</p>","body":""},"full_description":"<p>stop the fuse (clear the timeout).</p>","code":"stop: function(){\n    if (this.timerid) {\n      timers.clearTimeout(this.timerid);\n    }\n    return this;\n  }\n});","params":[],"has_params":false,"tags":[{"type":"return","types":["fuse"],"description":"this"},{"type":"memberOf","parent":"Fuse"},{"type":"name","string":"stop"}],"module":false,"parent":"Fuse","related":{"href":""},"has_related":true}]}]
  </script>

  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.6.4/jquery.min.js" type="text/javascript" charset="utf-8"></script>

  <script type="text/javascript" charset="utf-8">
    // lunr.js version: 0.0.4
    // (c) 2011 Oliver Nightingale
    //
    //  Released under MIT license.
    //
    var Lunr=function(c,f){var b=new Lunr.Index(c);f.call(b,b);return b};
    Lunr.utils={uniq:function(c){if(!c)return[];return c.reduce(function(c,b){c.indexOf(b)===-1&&c.push(b);return c},[])},intersect:function(c){var f=[].slice.call(arguments,1);return this.uniq(c).filter(function(b){return f.every(function(a){return a.indexOf(b)>=0})})},detect:function(c,f,b){for(var a=c.length,g=null,d=0;d<a;d++)if(f.call(b,c[d],d,c)){g=c[d];break}return g},copy:function(c){return Object.keys(c).reduce(function(f,b){f[b]=c[b];return f},{})}};
    Lunr.Trie=function(){var c=function(){this.children={};this.values=[]};c.prototype={childForKey:function(b){var a=this.children[b];a||(a=new c,this.children[b]=a);return a}};var f=function(){this.root=new c};f.prototype={get:function(b){var a=this;return this.keys(b).reduce(function(c,d){a.getNode(d).values.forEach(function(a){a=Lunr.utils.copy(a);if(b===d)a.exact=!0;c.push(a)});return c},[])},getNode:function(b){var a=function(b,d){if(!d.length)return b;return a(b.childForKey(d.charAt(0)),d.slice(1))};
    return a(this.root,b)},keys:function(b){var a=[];b=b||"";var c=function(b,e){b.values.length&&a.push(e);Object.keys(b.children).forEach(function(a){c(b.children[a],e+a)})};c(this.getNode(b),b);return a},set:function(b,a){var c=function(b,e){if(!e.length)return b.values.push(a);c(b.childForKey(e.charAt(0)),e.slice(1))};return c(this.root,b)}};return f}();Lunr.Index=function(c){this.name=c;this.refName="id";this.fields={};this.trie=new Lunr.Trie};
    Lunr.Index.prototype={add:function(c){(new Lunr.Document(c,this.refName,this.fields)).words().forEach(function(c){this.trie.set(c.id,c.docs[0])},this)},field:function(c,f){this.fields[c]=f||{multiplier:1}},ref:function(c){this.refName=c},search:function(c){if(!c)return[];c=c.split(" ").map(function(c){c=new Lunr.Word(c);if(!c.isStopWord())return c.toString()}).filter(function(c){return c}).map(function(c){return this.trie.get(c).sort(function(b,a){if(b.exact&&a.exact===void 0)return-1;if(a.exact&&
    b.exact===void 0)return 1;if(b.score<a.score)return 1;if(b.score>a.score)return-1;return 0}).map(function(b){return b.documentId})},this);return Lunr.utils.intersect.apply(Lunr.utils,c)}};Lunr.Document=function(c,f,b){this.original=c;this.fields=b;this.ref=c[f]};
    Lunr.Document.prototype={asJSON:function(){return{id:this.ref,words:this.words().map(function(c){return c.id}),original:this.original}},words:function(){var c=this,f={};Object.keys(this.fields).forEach(function(b){c.original[b].split(/\b/g).filter(function(a){return!!a.match(/\w/)}).map(function(a){a=new Lunr.Word(a);if(!a.isStopWord())return a.toString()}).filter(function(a){return a}).forEach(function(a){f[a]||(f[a]={score:0,ref:c.ref});f[a].score+=c.fields[b].multiplier})});return Object.keys(f).map(function(b){return{id:b,
    docs:[{score:f[b].score,documentId:c.ref}]}})}};Lunr.Word=function(c){this.raw=c;this.out=this.raw.replace(/^\W+/,"").replace(/\W+$/,"").toLowerCase()};Lunr.Word.stopWords=["the","of","to","and","a","in","is","it","you","that","this"];
    Lunr.Word.prototype={isStopWord:function(){return Lunr.Word.stopWords.indexOf(this.raw.toLowerCase())!==-1},toString:function(){if(!this.isStopWord())return this.stem(),this.out},stem:function(){var c={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},f={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",
    ful:"",ness:""};return function(){var b,a,g,d=g=this.out;if(g.length<3)return g;var e,h;g=g.substr(0,1);g=="y"&&(d=g.toUpperCase()+d.substr(1));e=/^(.+?)(ss|i)es$/;a=/^(.+?)([^s])s$/;e.test(d)?d=d.replace(e,"$1$2"):a.test(d)&&(d=d.replace(a,"$1$2"));e=/^(.+?)eed$/;a=/^(.+?)(ed|ing)$/;e.test(d)?(a=e.exec(d),e=/^([^aeiou][^aeiouy]*)?[aeiouy][aeiou]*[^aeiou][^aeiouy]*/,e.test(a[1])&&(e=/.$/,d=d.replace(e,""))):a.test(d)&&(a=a.exec(d),b=a[1],a=/^([^aeiou][^aeiouy]*)?[aeiouy]/,a.test(b)&&(d=b,a=/(at|bl|iz)$/,
    h=/([^aeiouylsz])\1$/,b=/^[^aeiou][^aeiouy]*[aeiouy][^aeiouwxy]$/,a.test(d)?d+="e":h.test(d)?(e=/.$/,d=d.replace(e,"")):b.test(d)&&(d+="e")));e=/^(.+?)y$/;e.test(d)&&(a=e.exec(d),b=a[1],e=/^([^aeiou][^aeiouy]*)?[aeiouy]/,e.test(b)&&(d=b+"i"));e=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/;e.test(d)&&(a=e.exec(d),b=a[1],a=a[2],e=/^([^aeiou][^aeiouy]*)?[aeiouy][aeiou]*[^aeiou][^aeiouy]*/,e.test(b)&&(d=b+c[a]));
    e=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/;e.test(d)&&(a=e.exec(d),b=a[1],a=a[2],e=/^([^aeiou][^aeiouy]*)?[aeiouy][aeiou]*[^aeiou][^aeiouy]*/,e.test(b)&&(d=b+f[a]));e=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/;a=/^(.+?)(s|t)(ion)$/;e.test(d)?(a=e.exec(d),b=a[1],e=/^([^aeiou][^aeiouy]*)?[aeiouy][aeiou]*[^aeiou][^aeiouy]*[aeiouy][aeiou]*[^aeiou][^aeiouy]*/,e.test(b)&&(d=b)):a.test(d)&&(a=a.exec(d),b=a[1]+a[2],a=/^([^aeiou][^aeiouy]*)?[aeiouy][aeiou]*[^aeiou][^aeiouy]*[aeiouy][aeiou]*[^aeiou][^aeiouy]*/,
    a.test(b)&&(d=b));e=/^(.+?)e$/;if(e.test(d)&&(a=e.exec(d),b=a[1],e=/^([^aeiou][^aeiouy]*)?[aeiouy][aeiou]*[^aeiou][^aeiouy]*[aeiouy][aeiou]*[^aeiou][^aeiouy]*/,a=/^([^aeiou][^aeiouy]*)?[aeiouy][aeiou]*[^aeiou][^aeiouy]*([aeiouy][aeiou]*)?$/,h=/^[^aeiou][^aeiouy]*[aeiouy][^aeiouwxy]$/,e.test(b)||a.test(b)&&!h.test(b)))d=b;e=/ll$/;a=/^([^aeiou][^aeiouy]*)?[aeiouy][aeiou]*[^aeiou][^aeiouy]*[aeiouy][aeiou]*[^aeiou][^aeiouy]*/;e.test(d)&&a.test(d)&&(e=/.$/,d=d.replace(e,""));g=="y"&&(d=g.toLowerCase()+
    d.substr(1));this.out=d}}()};
  </script>

  <script type="text/javascript" charset="utf-8">
    var idx = Lunr('methods', function () {
      this.ref('id')
      this.field('name', { multiplier: 10 })
      this.field('parent', { multiplier: 5 })
      this.field('full_description')
    })

    var methods = raw.reduce(function (memo, module) {
      return memo.concat(module.methods)
    }, [])

    methods.forEach(function (method) {
      idx.add(method)
    })

    $(document).ready(function () {

      var search = function (term) {
        return idx.search(term).map(function (id) {
          return methods.filter(function (method) {
            return method.id === id
          })[0]
        })
      }

      var searchResults = $('#search-results')

      $('#search-input').keyup(function () {
        var query = $(this).val(),
            results = search(query)

        if (!results.length) {
          searchResults.empty()
          return
        };

        var resultsList = results.reduce(function (ul, result) {
          var li = $('<li>').append($('<a>', {
            href: '#' + result.name,
            text: result.name
          }))

          ul.append(li)

          return ul
        }, $('<ul>'))

        searchResults.html(resultsList)
      })
    })
  </script>

  <style type="text/css" media="screen">
    body {
  font-family: 'Helvetica Neue';
  color: #333;
}

a {
  color: #0f4bf0;
}

header h1 {
  border-top: 4px solid #333;
  font-size: 2.6em;
}

header .version {
  font-size: 0.6em;
}

.main > header {
  margin-bottom: 40px;
}

article {
  margin-bottom: 10px;
  padding-bottom: 30px;
}

article header h2 {
  border-top: 3px solid #333;
  font-size: 2em;
  padding-top: 5px;
}

article > section {
  margin-bottom: 30px;
}

article section h3 {
  font-size: 1em;
}

article section header h3 {
  padding-top: 2px;
  font-size: 1.2em;
  margin-bottom: 5px;
  border-top: 2px solid #333;
}

article section header h4 {
  font-size: 0.9em;
  font-family: courier;
  margin: 2px 0 5px 0;
}

@-webkit-keyframes highlight {
  from {
    background-color: #Ffff66;
  }

  to {
    background-color: white;
  }
}

section.method:target {
  -webkit-animation-duration: 1s;
  -webkit-animation-name: highlight;
}

section header .type, section header .related {
  margin-top: 0px;
  font-size: 0.8em;
}

section.params h4, section.source h4 {
  margin-top: 5px;
  margin-bottom: 2px;
  font-size: 0.9em;
}

section.params ul {
  margin-top: 2px;
}

a.show-source {
  font-size: 0.8em;
}

.wrap {
  width: 960px;
  margin: 0 auto;
}

.main {
  width: 760px;
  float: left;
}

.search {
  margin-top: 10px;
  float: right;
}

#search-input {
  width: 200px;
}

#search-results {
  position: relative;
}

#search-results ul {
  width: 200px;
  position: absolute;
  top: 0px;
  left: 0px;
  background-color: white;
  border: 1px solid #ccc;
  list-style: none;
  padding: 0;
  margin-top: 0;
  font-size: 0.9em;
}

#search-results li {
  padding: 5px;
}

#search-results li:hover {
  background-color: #eee;
  cursor: pointer;
}

#search-results li a {
  text-decoration: none;
  width: 200px;
  display: block;
}

p {
  line-height: 1.4em;
}

nav {
  padding-top: 15px;
  float: left;
  width: 165px;
  margin-right: 30px;
  text-align: right;
  font-size: 0.8em;
}

nav ul {
  list-style: none;
  margin: 0;
  padding: 0;
}

nav ul h3 {
  margin-bottom: 5px;
  border-top: 2px solid #CCC;
  padding-top: 2px;
}

nav ul ul li {
  padding: 2px 0;
}

pre {
  background-color: rgba(0,0,0,0.1);
  padding: 8px;
}

code .keyword, code .special {
  font-weight: bold;
  color: black;
}

code .string, code .regexp {
  color: green
}

code .class { 
  color: blue
}

code .number {
  color: red
}

code .comment {
  color: grey;
  font-style: italic;
}
  </style>
</head>
<body>
  <div class='wrap'>


    <nav>
      <ul>
        
          <li>
            <a href='#main'>
              <h3>main</h3>
            </a>

            <ul>
              
                <li><a href='#main-requireAny'>requireAny</a></li>
              
                <li><a href='#main-uu'>uu</a></li>
              
                <li><a href='#main-GOODSTATUS'>GOODSTATUS</a></li>
              
                <li><a href='#main-UPLOAD_URL'>UPLOAD_URL</a></li>
              
                <li><a href='#main-requestError'>requestError</a></li>
              
                <li><a href='#main-snoop'>snoop</a></li>
              
                <li><a href='#main-killaddon'>killaddon</a></li>
              
            </ul>
          </li>
        
          <li>
            <a href='#EventStore'>
              <h3>EventStore</h3>
            </a>

            <ul>
              
                <li><a href='#EventStore-initialize'>initialize</a></li>
              
                <li><a href='#EventStore-db'>db</a></li>
              
                <li><a href='#EventStore-add'>add</a></li>
              
                <li><a href='#EventStore-clear'>clear</a></li>
              
            </ul>
          </li>
        
          <li>
            <a href='#Micropilot'>
              <h3>Micropilot</h3>
            </a>

            <ul>
              
                <li><a href='#Micropilot-initialize'>initialize</a></li>
              
                <li><a href='#Micropilot-startdate'>startdate</a></li>
              
                <li><a href='#Micropilot-data'>data</a></li>
              
                <li><a href='#Micropilot-clear'>clear</a></li>
              
                <li><a href='#Micropilot-record'>record</a></li>
              
                <li><a href='#Micropilot-lifetime'>lifetime</a></li>
              
                <li><a href='#Micropilot-start'>start</a></li>
              
                <li><a href='#Micropilot-stop'>stop</a></li>
              
                <li><a href='#Micropilot-_watch'>_watch</a></li>
              
                <li><a href='#Micropilot-watch'>watch</a></li>
              
                <li><a href='#Micropilot-_unwatch'>_unwatch</a></li>
              
                <li><a href='#Micropilot-unwatch'>unwatch</a></li>
              
                <li><a href='#Micropilot-ezupload'>ezupload</a></li>
              
                <li><a href='#Micropilot-upload'>upload</a></li>
              
            </ul>
          </li>
        
          <li>
            <a href='#Fuse'>
              <h3>Fuse</h3>
            </a>

            <ul>
              
                <li><a href='#Fuse-initialize'>initialize</a></li>
              
                <li><a href='#Fuse-then'>then</a></li>
              
                <li><a href='#Fuse-stop'>stop</a></li>
              
            </ul>
          </li>
        
      </ul>
    </nav>

    <div class='main'>
      <header>
        <div class='search'>
          <input type="search" id="search-input" placeholder="Search"></input>
          <div id="search-results"></div>
        </div>
        <h1>Micropilot <span class='version'>0.6</span></h1>
      </header>

      
        <article id='main'>
          <header>
            <h2>main</h2>
          </header>

          <section>
            <p>Example Usage for module:</p>

<p>Usage:</p>

<div class="highlight"><pre lang=""> Micropilot('mystudy').start().record({'a':1}).then(function(mtp){
   mtp.upload(UPLOAD_URL + mtp.studyid);
 })
</pre></div>

<p>record <code>{a:1, ts: Date.now()}</code>.  Then upload.</p>

<div class="highlight"><pre lang="">require('micropilot').Micropilot('simplestudyid').start().
   record({a:1,ts: Date.now()}).then(function(m) m.ezupload())
   // which actually uploads!
</pre></div>

<p>For 1 day, record any data notified on <code>Observer</code> topics <code>['topic1', 'topic2']</code> then upload to <code>&lt;url&gt;</code>, after that 24 hour <code>Fuse</code> completes.</p>

<div class="highlight"><pre lang="">require("micropilot").Micropilot('otherstudyid').start().watch(['topic1','topic2']).
  lifetime(24 * 60 * 60 * 1000).then(
    function(mtp){ mtp.upload(url); mtp.stop() })
</pre></div>

<p>How a more realistic study might look.</p>

<div class="highlight"><pre lang="">let monitor_tabopen = require('micropilot').Micropilot('tapopenstudy');
var tabs = require('tabs');
tabs.on('ready', function () {
  monitor_tabopen.record({'msg:' 'tab ready', 'ts': Date.now()})
});

monitor_tabopen.lifetime(86400*1000).then(function(mon){mon.ezupload()});
  // Fuse:  24 hours-ish after first start, upload

if (user_tells_us_to_stop_snooping){
  monitor_tabopen.stop();
}
</pre></div>
          </section>

          
            <section class='method' id='main-requireAny'>
              <header>
                <h3>requireAny</h3>
                <h4>requireAny()</h4>
                <p class='type'>function</p>
                
                  <p class='related'>See: <a href='#'>requireAny</a></p>
                
              </header>

              <section class='params'>
                
                  <h4>Params</h4>
                
                <ul>
                  
                    <li>paths - strings of module paths to try</li>
                  
                    <li>msg - throw message on failure of all paths (default: &quot;No such module&quot;)</li>
                  
                </ul>
              </section>

              

              <section>
                <p>Return first-successful reqiured module from a list of paths</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>function requireAny(paths,msg) {
  msg = msg ||  &quot;No such module&quot;;
  // path of paths
  for (let i = 0, ii = paths.length; i &lt; ii; i++) {
    try {
      return require(paths[i]);
    } catch (e) {
      console.log(e);
    }
  } throw msg;
};</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='main-uu'>
              <header>
                <h3>uu</h3>
                <h4></h4>
                <p class='type'></p>
                
                  <p class='related'>See: <a href='#'>uu</a></p>
                
              </header>

              <section class='params'>
                
                <ul>
                  
                </ul>
              </section>

              

              <section>
                <p>Random UUID as string, without braces.</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>let uu = exports.uu = function(){
        return uuid().number.slice(1,-1)
};</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='main-GOODSTATUS'>
              <header>
                <h3>GOODSTATUS</h3>
                <h4></h4>
                <p class='type'></p>
                
                  <p class='related'>See: <a href='#'>GOODSTATUS</a></p>
                
              </header>

              <section class='params'>
                
                <ul>
                  
                </ul>
              </section>

              

              <section>
                <p>Object with "passing" HTTP status codes.</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>const GOODSTATUS = exports.GOODSTATUS = {
  //&quot;O&quot;: 0,
  &quot;200&quot;: 200,
  &quot;201&quot;: 201,
  &quot;202&quot;: 202,
  &quot;203&quot;: 203,
  &quot;204&quot;: 204
};</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='main-UPLOAD_URL'>
              <header>
                <h3>UPLOAD_URL</h3>
                <h4></h4>
                <p class='type'></p>
                
                  <p class='related'>See: <a href='#'>UPLOAD_URL</a></p>
                
              </header>

              <section class='params'>
                
                <ul>
                  
                </ul>
              </section>

              

              <section>
                <p>Upload url</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>let UPLOAD_URL = exports.UPLOAD_URL = &quot;https://testpilot.mozillalabs.com/submit/testpilot_micropilot_&quot;;</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='main-requestError'>
              <header>
                <h3>requestError</h3>
                <h4></h4>
                <p class='type'></p>
                
                  <p class='related'>See: <a href='#'>requestError</a></p>
                
              </header>

              <section class='params'>
                
                <ul>
                  
                </ul>
              </section>

              

              <section>
                <p>common generic function to handle request errors</p>

<p>Console errors the error code.</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>let requestError = function(evt) console.error(&quot;ERROR&quot;,evt.target.errorCode);
let requestBlocked = function(evt) console.log(&quot;BLOCKED&quot;,evt);</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='main-snoop'>
              <header>
                <h3>snoop</h3>
                <h4></h4>
                <p class='type'></p>
                
                  <p class='related'>See: <a href='#'>snoop</a></p>
                
              </header>

              <section class='params'>
                
                <ul>
                  
                </ul>
              </section>

              

              <section>
                <p>gather general user data, including addons, os, etc.</p>

<p>Properties:  appname, location, fxVersion, os, updateChannel, addons list</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>let snoop = exports.snoop = function(){
  let { promise, resolve } = defer();
  let LOCALE_PREF = &quot;general.useragent.locale&quot;;
  let UPDATE_CHANNEL_PREF = &quot;app.update.channel&quot;;
  let xa = require(&quot;xul-app&quot;);
  let prefs = require('preferences-service');

  let u = {};
  u.appname = xa.name;
  u.location = prefs.get(LOCALE_PREF)
  u.fxVersion = xa.version;
  u.os = require('runtime').os;
  u.updateChannel = prefs.get(UPDATE_CHANNEL_PREF)

  let { AddonManager } = Cu.import(&quot;resource://gre/modules/AddonManager.jsm&quot;);
  u.addons = [];
  AddonManager.getAllAddons(function(addonList){
    Array.forEach(addonList,function(a){
      let o = {};
      ['id','name','appDisabled','isActive','type','userDisabled'].forEach(function(k){
        o[k] = a[k]
      })
      u.addons.push(o);
    })
    resolve(u);
  })
  return promise;
}</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='main-killaddon'>
              <header>
                <h3>killaddon</h3>
                <h4></h4>
                <p class='type'></p>
                
                  <p class='related'>See: <a href='#'>killaddon</a></p>
                
              </header>

              <section class='params'>
                
                <ul>
                  
                </ul>
              </section>

              

              <section>
                <p>Self-destruct (uninstall) this addon</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>let killaddon = exports.killaddon = function(){
  let id = require('self').id;
  microlog(&quot;attempting to remove addon:&quot;, id);
  require(&quot;sdk/addon/installer&quot;).uninstall(id);
}</code></pre>
              </section>
              
            </section>
          
        </article>
      
        <article id='EventStore'>
          <header>
            <h2>EventStore</h2>
          </header>

          <section>
            <p>EventStore Constructor (Heritage)</p>
          </section>

          
            <section class='method' id='EventStore-initialize'>
              <header>
                <h3>initialize</h3>
                <h4></h4>
                <p class='type'></p>
                
                  <p class='related'>See: <a href='#'>initialize</a></p>
                
              </header>

              <section class='params'>
                
                  <h4>Params</h4>
                
                <ul>
                  
                    <li>collection - used in db and objectStore names.</li>
                  
                    <li>key - autoincrement key, (default: &quot;eventstoreid&quot;)</li>
                  
                </ul>
              </section>

              

              <section>
                <p>Create an event store.</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>initialize: function(collection,keyname){
    this.collection = collection;
    this.keyname = keyname || &quot;eventstoreid&quot;;
  },
  type: &quot;EventStore&quot;,</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='EventStore-db'>
              <header>
                <h3>db</h3>
                <h4></h4>
                <p class='type'></p>
                
                  <p class='related'>See: <a href='#'>db</a></p>
                
              </header>

              <section class='params'>
                
                <ul>
                  
                </ul>
              </section>

              

              <section>
                <p>promise a indexedDB connection to <code>"micropilot-"+this.collection</code>.</p>

<p>If first connection to db, creates object store:</p>

<p><code>createObjectStore(that.collection,{keyPath: that.keyname, autoIncrement: true }</code></p>

<p>Resolves on success with (<code>request.result</code>)</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>db: function(){
    let that = this;
    let {promise, resolve} = defer();
    // TODO each EventStore has different Db, so the createObjectStore will work.  Is this gross?
    let req = indexedDB.open(&quot;micropilot-&quot;+that.collection,1);
    req.onerror = requestError;
    req.onupgradeneeded = function (event) {
      let objectStore = req.result.createObjectStore(that.collection,
        {keyPath: that.keyname, autoIncrement: true });
      microlog(&quot;micropilot-object-store-made:&quot;, that.collection )
    };
    // called after onupgradeneeded
    req.onsuccess = function(event) {
      resolve(req.result);
    };
    req.onblocked = requestBlocked;

    return promise
  },</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='EventStore-add'>
              <header>
                <h3>add</h3>
                <h4></h4>
                <p class='type'></p>
                
                  <p class='related'>See: <a href='#'>add</a></p>
                
              </header>

              <section class='params'>
                
                  <h4>Params</h4>
                
                <ul>
                  
                    <li>data - jsonable data</li>
                  
                </ul>
              </section>

              

              <section>
                <p>promises to add data to the autoincrementing objectStore.</p>

<p>Resolves on success with (<code>{id: newkey, data:data}</code>)</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>add: function(data){
    let that = this;
    let {promise, resolve} = defer();
    this.db().then(function(db){
      let req = db.transaction([that.collection], &quot;readwrite&quot;).
        objectStore(that.collection).add(data);
      req.onsuccess = function (evt) {
        let newkey = evt.target.result;
        resolve({id: newkey, data:data});
      };
      req.onerror = requestError;
      req.onblocked = requestBlocked;

    })
    return promise
  },</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='EventStore-clear'>
              <header>
                <h3>clear</h3>
                <h4></h4>
                <p class='type'></p>
                
                  <p class='related'>See: <a href='#'>clear</a></p>
                
              </header>

              <section class='params'>
                
                <ul>
                  
                </ul>
              </section>

              

              <section>
                <p>promise to drop the database.</p>

<p>Resolves onsuccess (<code>request.result</code>)</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>clear: function(){
    let that = this;
    let {promise, resolve} = defer();
    let req = indexedDB.deleteDatabase(&quot;micropilot-&quot;+that.collection,1);
    req.onsuccess = function(event) {
      resolve(req.result);
    }
    req.onerror = requestError;
    req.onblocked = requestBlocked;
    return promise;
  }
});</code></pre>
              </section>
              
            </section>
          
        </article>
      
        <article id='Micropilot'>
          <header>
            <h2>Micropilot</h2>
          </header>

          <section>
            <p>Micropilot Heritage Object</p>

<p>Persists over multiple runs. (Persistence achieved using <code>simple-store</code>, which ties a Micropilot into a particular addon)</p>
          </section>

          
            <section class='method' id='Micropilot-initialize'>
              <header>
                <h3>initialize</h3>
                <h4></h4>
                <p class='type'></p>
                
                  <p class='related'>See: <a href='#'>initialize</a></p>
                
              </header>

              <section class='params'>
                
                  <h4>Params</h4>
                
                <ul>
                  
                    <li>studyid - Id for persistent store, db.</li>
                  
                </ul>
              </section>

              

              <section>
                <p>Initialize the Micropilot</p>

<p>internals:</p>

<ul>
<li><code>_watched</code>: observed topics</li>
<li><code>eventstore</code>: an EventStore</li>
<li><code>_config</code>: simple-store configuration
<ul><li><code>personid</code>:  a <code>uu()</code>  (set this if you want.)</li>
<li><code>_startdate</code>:  now, or then (if revived)</li></ul></li>
<li><code>willrecord</code>:  a brake on event recording</li>
</ul>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>initialize: function(studyid){
      // setup the indexdb
      this.studyid = studyid;
      this._watched = {};
      this.eventstore = EventStore(this.studyid);
      this._config = storage.micropilot[studyid]; // persists
      if (this._config === undefined) {
        this._config = {};
        this._config.personid = uu();
      }
      this._startdate = this._config.startdate = Date.now(); // start now
      this.willrecord = false; // won't record.
  },
  type: 'Micropilot',</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='Micropilot-startdate'>
              <header>
                <h3>startdate</h3>
                <h4></h4>
                <p class='type'></p>
                
                  <p class='related'>See: <a href='#'>startdate</a></p>
                
              </header>

              <section class='params'>
                
                <ul>
                  
                </ul>
              </section>

              

              <section>
                <p>get and set the startDate</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>get startdate() this._startdate,
  // resetting the startdate kills existing lifetime / fuse
  set startdate(ts) {
    this.stop();
    this._startdate = ts;
  },</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='Micropilot-data'>
              <header>
                <h3>data</h3>
                <h4></h4>
                <p class='type'></p>
                
                  <p class='related'>See: <a href='#'>data</a></p>
                
              </header>

              <section class='params'>
                
                <ul>
                  
                </ul>
              </section>

              

              <section>
                <p>promise of all recorded event data</p>

<p>Resolve (<code>data</code>)</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>data: function() this.eventstore.getAll(),</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='Micropilot-clear'>
              <header>
                <h3>clear</h3>
                <h4></h4>
                <p class='type'></p>
                
                  <p class='related'>See: <a href='#'>clear</a></p>
                
              </header>

              <section class='params'>
                
                <ul>
                  
                </ul>
              </section>

              

              <section>
                <p>promise to clear all data (by dropping the db)</p>

<p>Resolve(<code>request.response</code>) // of the dropDatabse</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>clear: function() this.eventstore.clear(),</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='Micropilot-record'>
              <header>
                <h3>record</h3>
                <h4></h4>
                <p class='type'></p>
                
                  <p class='related'>See: <a href='#'>record</a></p>
                
              </header>

              <section class='params'>
                
                <ul>
                  
                </ul>
              </section>

              

              <section>
                <p>promise of <code>EventStore.add</code>, which is {id:&lt;>,data:&lt;>} unless record "doesn't happen" because of non-running</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>record: function(data){
    // remember, `resolve` turns values into promises, and is noop on promises
    if (! this.willrecord) return resolve(undefined);

    // todo, what if it's not jsonable?
    JSON.stringify(data);
    microlog(&quot;micropilot-record:&quot;, JSON.stringify(data));
    return this.eventstore.add(data)
  },</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='Micropilot-lifetime'>
              <header>
                <h3>lifetime</h3>
                <h4></h4>
                <p class='type'></p>
                
                  <p class='related'>See: <a href='#'>lifetime</a></p>
                
              </header>

              <section class='params'>
                
                  <h4>Params</h4>
                
                <ul>
                  
                    <li>duration - milliseconds to run Fuse</li>
                  
                </ul>
              </section>

              

              <section>
                <p>promise the study (setting a Fuse)</p>

<p>Fuse set as {start: this.startdate,duration:duration} (modify startdate to 'run from some other time')</p>

<p>False or Undefined duration subls forever / never resolves</p>

<p>Note:  calls <code>stop()</code> and <code>start()</code> as side-effects</p>

<p>Resolves when the study fuse resolves.</p>

<p>example:</p>

<p><code>Micropilot('mystudy').lifetime(1000).then(function(mtp){mtp.stop()})</code></p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>lifetime:  function(duration){
    this.stop();
    this.willrecord = true; // restart!
    let deferred = defer();
    let that = this;
    // iff!
    if (duration){
      // should this allow / mix all fuse options?
      this.fuse = Fuse({start: this.startdate,duration:duration, resolve_this: that});
      return this.fuse;
    } else {
      // no duration, so infinite, so nothing to resolve.
    }
    this.start();
    return deferred.promise;
  },</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='Micropilot-start'>
              <header>
                <h3>start</h3>
                <h4></h4>
                <p class='type'></p>
                
                  <p class='related'>See: <a href='#'>start</a></p>
                
              </header>

              <section class='params'>
                
                <ul>
                  
                </ul>
              </section>

              

              <section>
                <p>allow record (<code>this.willrecord</code> -> <code>true</code>)</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>start:  function(){
    this.willrecord = true;
    return this;
  },</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='Micropilot-stop'>
              <header>
                <h3>stop</h3>
                <h4></h4>
                <p class='type'></p>
                
                  <p class='related'>See: <a href='#'>stop</a></p>
                
              </header>

              <section class='params'>
                
                <ul>
                  
                </ul>
              </section>

              

              <section>
                <p>stop the study (unset the fuse, <code>this.willrecord</code> -> <code>false</code>)</p>

<p>(after stopping, <code>record</code> will not work, unless one <code>start()</code> or or <code>willrecord</code> -> <code>true</code>)</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>stop:  function(){
    this.willrecord = false;
    this.fuse !== undefined &amp;&amp; this.fuse.stop();
    delete this.fuse;
    return this;
  },</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='Micropilot-_watch'>
              <header>
                <h3>_watch</h3>
                <h4></h4>
                <p class='type'></p>
                
                  <p class='related'>See: <a href='#'>_watch</a></p>
                
              </header>

              <section class='params'>
                
                  <h4>Params</h4>
                
                <ul>
                  
                    <li>topic - topic to watch.</li>
                  
                </ul>
              </section>

              

              <section>
                <p>(internal) watch a topic, add to <code>observer-service</code></p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>_watch: function(topic){
    if (this._watched[topic]) return

    let that = this;
    let cb;
    if (this._watchfn !== undefined){
      cb = function(subject) that._watchfn.call(that,topic,subject);
    } else {
      cb = function(subject) {that.record({&quot;msg&quot;:topic,ts:Date.now(),&quot;data&quot;:subject})};
    }
    let o = observer.add(topic,cb); // add to global watch list
    this._watched[topic] = cb;
  },</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='Micropilot-watch'>
              <header>
                <h3>watch</h3>
                <h4></h4>
                <p class='type'></p>
                
                  <p class='related'>See: <a href='#'>watch</a></p>
                
              </header>

              <section class='params'>
                
                  <h4>Params</h4>
                
                <ul>
                  
                    <li>watch_list - list of topics</li>
                  
                </ul>
              </section>

              

              <section>
                <p>add topics to watch (non-destructive)</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>watch: function(watch_list){
      let that = this;
      watch_list.forEach(function(t) that._watch(t))
      return this;
  },</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='Micropilot-_unwatch'>
              <header>
                <h3>_unwatch</h3>
                <h4></h4>
                <p class='type'></p>
                
                  <p class='related'>See: <a href='#'>_unwatch</a></p>
                
              </header>

              <section class='params'>
                
                <ul>
                  
                </ul>
              </section>

              

              <section>
                <p>(internal) stop watching topic</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>_unwatch: function(topic){
    let cb = this._watched[topic];
    cb &amp;&amp; observer.remove(topic,cb);
    delete this._watched[topic];
  },</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='Micropilot-unwatch'>
              <header>
                <h3>unwatch</h3>
                <h4></h4>
                <p class='type'></p>
                
                  <p class='related'>See: <a href='#'>unwatch</a></p>
                
              </header>

              <section class='params'>
                
                  <h4>Params</h4>
                
                <ul>
                  
                    <li>unwatch_list - list of topics to remove. If undefined, unwatch all.</li>
                  
                </ul>
              </section>

              

              <section>
                <p>unwatch some topics (destructive) if <code>unwatch_list</code> is undefined, unwatch all.</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>unwatch: function(unwatch_list){
    if (unwatch_list === undefined) unwatch_list = Object.keys(this._watched);
    let that = this;
    unwatch_list.forEach(function(t) that._unwatch(t));
    return this;
  },</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='Micropilot-ezupload'>
              <header>
                <h3>ezupload</h3>
                <h4></h4>
                <p class='type'></p>
                
                  <p class='related'>See: <a href='#'>ezupload</a></p>
                
              </header>

              <section class='params'>
                
                  <h4>Params</h4>
                
                <ul>
                  
                    <li>options - Upload options.</li>
                  
                </ul>
              </section>

              

              <section>
                <p>promise simplified upload with strong opinions and retry semantics</p>

<p>Options:</p>

<ul>
<li><code>url</code>:  defaults to <code>UPLOAD_URL + mtp.studyname</code></li>
<li><code>maxtries</code>:  Number of tries.  (<code>3</code>)</li>
<li><code>interval</code>:  How long to wait between tries (60 min - <code>60*60*1000</code>)</li>
<li><code>killaddon</code>:  Should the addon delete itself on completion? (<code>false</code>)</li>
</ul>

<p><em>Note 1</em>:  <a href='https://github.com/gregglind/micropilot/issues/2'>https://github.com/gregglind/micropilot/issues/2</a></p>

<p><em>Note 2</em>:  <code>_config.completed</code> will will go to <code>true</code> on success or not.</p>

<p><em>Note 3</em>:  Adds some keys to <code>_config</code> persistence:</p>

<ul>
<li><code>completed</code></li>
<li><code>uploadcounter</code></li>
</ul>

<p>This is Subject To Change, and just a starting point for how to talk about study state.</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>ezupload: function(options){
    let { promise, resolve } = defer();
    let {url,maxtries,interval,killaddon:killpref} = options;
    let that = this;
    url = url || (UPLOAD_URL + that.studyid);
    microlog(&quot;micropilot-ezupload:&quot;,url );

    maxtries = maxtries || 3
    interval = interval || 60 * 60 * 1000; // 60 minutes

    let mycleanup = function(){
        that._config.completed = true ; // whatever properties you want
        let p = that.stop();
        p = that.clear();
        if (killpref) {
          microlog(&quot;micropilot: killpref on!&quot;)
          resolve(p.then(killaddon));   // stop the study, clear the data, uninstall the addon.
        } else {
          resolve(p)
        }
    }

    if (this._config.uploadcounter === undefined) this._config.uploadcounter = 0;
    let myupload = function() {
      if (that._config.uploadcounter &gt;= maxtries) { mycleanup(that); return};  // give up!
      that._config.uploadcounter += 1;

      that.upload(url).then(function(response){
        if (! GOODSTATUS[response.status]) {  // try again in interval ms
          microlog(&quot;micropilot-response-bad:&quot;, response.status, &quot;retrying in:&quot;, interval );
          require('timers').setTimeout(function(){myupload()}, interval)
        } else {
          microlog(&quot;micropilot-ezupload-success&quot;)
          mycleanup();
        }
      })
    }
    myupload();
    return promise;
  },</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='Micropilot-upload'>
              <header>
                <h3>upload</h3>
                <h4></h4>
                <p class='type'></p>
                
                  <p class='related'>See: <a href='#'>upload</a></p>
                
              </header>

              <section class='params'>
                
                  <h4>Params</h4>
                
                <ul>
                  
                    <li>url - url to POST.</li>
                  
                    <li>options - some options, below.</li>
                  
                </ul>
              </section>

              

              <section>
                <p>promise to upload the data</p>

<p>Options: - <code>simulate</code>:  don't post, promise the request - <code>uploadid</code>:  an id for the upload</p>

<p>Resolves - if POST, after oncomplete (response) - if <code>options.simulate</code> (request)</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>upload:  function(url,options){
    // get all... is this tangled between getting and posting?
    // attempt to post
    options = options===undefined ? {} : options;
    let that = this;
    let simulate = options.simulate;
    let { promise, resolve } = defer();
    let uploadid = options.uploadid || uu(); // specific to the upload
    this.data().then(function(data){
      microlog(&quot;micropilot-willupload-data:&quot;, JSON.stringify(data));
      let payload = {events:data};
      payload.userdata = snoop();
      payload.ts = Date.now();
      payload.uploadid = uploadid;
      payload.personid = that._config.personid;
      snoop().then(function(userdata){
        microlog(&quot;micropilot-willupload-content:&quot;, JSON.stringify(payload));
        payload.userdata = userdata;
        let R = Request({
          url: url,
          headers: {
          },
          content: JSON.stringify(payload),
          contentType: &quot;application/json&quot;,

          onComplete: function (response) {
            microlog(&quot;micropilot-upload-response:&quot;,response.status);
            microlog(&quot;micropilot-upload-response:&quot;,response.text);
            resolve(response) },
        });
        if (simulate) {
          resolve(R);
        } else {
          R.post();
        }
      })
    });
    return promise;
  }

});</code></pre>
              </section>
              
            </section>
          
        </article>
      
        <article id='Fuse'>
          <header>
            <h2>Fuse</h2>
          </header>

          <section>
            <p>Fuse Heritage Class</p>
          </section>

          
            <section class='method' id='Fuse-initialize'>
              <header>
                <h3>initialize</h3>
                <h4></h4>
                <p class='type'></p>
                
                  <p class='related'>See: <a href='#'>initialize</a></p>
                
              </header>

              <section class='params'>
                
                  <h4>Params</h4>
                
                <ul>
                  
                    <li>options - </li>
                  
                </ul>
              </section>

              

              <section>
                <p>Fuses trigger (resolve their promise) no sooner than <code>duration + start</code></p>

<p>(like a dynamite fuse)</p>

<p>Options:</p>

<ul>
<li><code>start</code>:  start time for the fuse</li>
<li><code>duration</code>: how long to run.</li>
<li><code>pulseinterval</code>:  if defined, use a <code>setInterval</code> timer (see below)</li>
<li><code>resolve_this</code>:  the <code>this</code> passed into the <code>then</code> during resolution (default undefined)</li>
<li><code>pulsefn</code>:  if <code>setInterval</code> timer, run this function during every <code>pulse</code></li>
</ul>

<p><code>setInterval</code> vs. <code>setTimeout</code>:  Fuse is normally a <code>setTimeout</code>.  If you want finer control over it (including being able to modify the timers of running Fuses), use <code>pulseInterval</code> to make a <code>setInterval</code> timer.</p>

<p>Note 1: "Short Fuses":  When the <code>duration</code> is very short, we don't guaranteed millisecond accuracy!</p>

<p>Note 2:  Restart.  If a Fuse 'should fire' while Firefox is not running, it will fire the next time it can.</p>

<p>Note 3:  Blast from the Past.  Fuses fire IFF</p>

<p><div class="highlight"><pre lang="">  Date.now() >= (that.start + that.duration)   </pre></div></p>

<p>Note 4: Persist a fuse over restarts.</p>

<div class="highlight"><pre lang="">  let {storage} = require("simple-storage");
  if (! storage.firststart) ss.firststart = Date.now(); // tied to addon
  Fuse({start: storeage.firststart,duration:86400 * 7 * 1000 }).then(
   function(){ Micropilot('delayedstudy').start()} )
</pre></div>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>initialize: function(options){
    let {start,duration,pulseinterval,resolve_this,pulsefn} = options;
    this.pulseinterval =  pulseinterval;
    let that = this;
    this.start = start;
    this.duration = duration;
    let { promise, resolve } = defer();
    this.promise = promise;
    this.resolve = resolve;
    // should this be setInterval, or setTimeout?
    // setInterval allows one to modify the fuse while running
    // more easily, but setTimeout is much more precise.
    if (pulseinterval){
      this.timerid = timers.setInterval(function(){
        if (that.checking) {
          return;  // prevent races
        }
        that.checking = true;
        if (pulsefn) {pulsefn(that)}
        if (! duration) return;
        if (Date.now() &gt;= (that.start + that.duration)){
          that.resolve(resolve_this);
          that.stop();
        }
        that.checking=false;
      },pulseinterval);
    } else {
      // TODO, what is setTimeout on a negative?
      that.checking=false;
      let timerunningsofar = (Date.now() - this.start);
      if (duration &lt;= timerunningsofar) { // really short intervals
        that.resolve(resolve_this);
        this.stop();
      } else {
        this.timerid = timers.setTimeout(function(){
          that.resolve(resolve_this);
          that.stop();
        }, duration - timerunningsofar);
      }
    }
  },</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='Fuse-then'>
              <header>
                <h3>then</h3>
                <h4></h4>
                <p class='type'></p>
                
                  <p class='related'>See: <a href='#'>then</a></p>
                
              </header>

              <section class='params'>
                
                <ul>
                  
                </ul>
              </section>

              

              <section>
                <p>promise the promise.  Resolves with <code>resolve_this</code></p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>get then() this.promise.then,

  type: 'Fuse',</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='Fuse-stop'>
              <header>
                <h3>stop</h3>
                <h4></h4>
                <p class='type'></p>
                
                  <p class='related'>See: <a href='#'>stop</a></p>
                
              </header>

              <section class='params'>
                
                <ul>
                  
                </ul>
              </section>

              

              <section>
                <p>stop the fuse (clear the timeout).</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>stop: function(){
    if (this.timerid) {
      timers.clearTimeout(this.timerid);
    }
    return this;
  }
});</code></pre>
              </section>
              
            </section>
          
        </article>
      
    </div>
  </div>
  <script>
    (function (hijs) {
    //
    // hijs - JavaScript Syntax Highlighter
    //
    // Copyright (c) 2010 Alexis Sellier
    //

    // All elements which match this will be syntax highlighted.
    var selector = hijs || 'code';

    var keywords = ('var function if else for while break switch case do new null in with void '
                   +'continue delete return this true false throw catch typeof with instanceof').split(' '),
        special  = ('eval window document undefined NaN Infinity parseInt parseFloat '
                   +'encodeURI decodeURI encodeURIComponent decodeURIComponent').split(' ');

    // Syntax definition
    // The key becomes the class name of the <span>
    // around the matched block of code.
    var syntax = [
      ['comment', /(\/\*(?:[^*\n]|\*+[^\/*])*\*+\/)/g],
      ['comment', /(\/\/[^\n]*)/g],
      ['string' , /("(?:(?!")[^\\\n]|\\.)*"|'(?:(?!')[^\\\n]|\\.)*')/g],
      ['regexp' , /(\/.+\/[mgi]*)(?!\s*\w)/g],
      ['class'  , /\b([A-Z][a-zA-Z]+)\b/g],
      ['number' , /\b([0-9]+(?:\.[0-9]+)?)\b/g],
      ['keyword', new(RegExp)('\\b(' + keywords.join('|') + ')\\b', 'g')],
      ['special', new(RegExp)('\\b(' + special.join('|') + ')\\b', 'g')]
    ];
    var nodes, table = {};

    if (/^[a-z]+$/.test(selector)) {
        nodes = document.getElementsByTagName(selector);
    } else if (/^\.[\w-]+$/.test(selector)) {
        nodes = document.getElementsByClassName(selector.slice(1));
    } else if (document.querySelectorAll) {
        nodes = document.querySelectorAll(selector);
    } else {
        nodes = [];
    }

    for (var i = 0, children; i < nodes.length; i++) {
        children = nodes[i].childNodes;

        for (var j = 0, str; j < children.length; j++) {
            code = children[j];

            if (code.length >= 0) { // It's a text node
                // Don't highlight command-line snippets
                if (! /^\$/.test(code.nodeValue.trim())) {
                    syntax.forEach(function (s) {
                        var k = s[0], v = s[1];
                        code.nodeValue = code.nodeValue.replace(v, function (_, m) {
                            return '\u00ab' + encode(k) + '\u00b7'
                                            + encode(m) +
                                   '\u00b7' + encode(k) + '\u00bb';
                        });
                    });
                }
            }
        }
    }
    for (var i = 0; i < nodes.length; i++) {
        nodes[i].innerHTML =
            nodes[i].innerHTML.replace(/\u00ab(.+?)\u00b7(.+?)\u00b7\1\u00bb/g, function (_, name, value) {
                value = value.replace(/\u00ab[^\u00b7]+\u00b7/g, '').replace(/\u00b7[^\u00bb]+\u00bb/g, '');
                return '<span class="' + decode(name) + '">' + escape(decode(value)) + '</span>';
        });
    }

    function escape(str) {
        return str.replace(/</g, '&lt;').replace(/>/g, '&gt;');
    }

    // Encode ASCII characters to, and from Braille
    function encode (str, encoded) {
        table[encoded = str.split('').map(function (s) {
            if (s.charCodeAt(0) > 127) { return s }
            return String.fromCharCode(s.charCodeAt(0) + 0x2800);
        }).join('')] = str;
        return encoded;
    }
    function decode (str) {
        if (str in table) {
            return table[str];
        } else {
            return str.trim().split('').map(function (s) {
                if (s.charCodeAt(0) - 0x2800 > 127) { return s }
                return String.fromCharCode(s.charCodeAt(0) - 0x2800);
            }).join('');
        }
    }

    })(window.hijs);
  </script>
</body>
